/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.v2.generated;

/**
 * The Grammar generated by JavaCC
 */
public class Grammar {
    public static void main(String args[]) {
        System.out.println("Reading from standard input...");
        Grammar grammar = new Grammar(System.in);
        while (true) {
            try {
                ASTStart start = grammar.StartCommandLine();
                GrammarVisitor visitor = new GrammarDumpVisitor();
                start.jjtAccept(visitor, null);
                System.out.println("Thank you.");
            } catch (Exception e) {
                System.out.println("Oops.");
                System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN : { < TIMESTAMP: "at" | "on" | "during" | "in" > }
TOKEN : { < WHERE: "where" > }

TOKEN : /* CONJUNCTIONS */
{
  < CONJ: <CONJUNCTION> | <DISJUNCTION> >
|
  < #CONJUNCTION: "and" | "&&" | "&" >
|
  < #DISJUNCTION: "or" | "||" | "|" >
}

TOKEN :
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> | <REGEX> | <NOT_REGEX> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < #EQUALS: "=" | "==" | "eq" >
|
  < #NOT_EQUALS: "!=" | "ne" >
|
  < #GREATER_THAN: ">" | "gt" >
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" >
|
  < #LESS_THAN: "<" | "lt" >
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" >
|
  < #LINKS_TO: "->" | "lnks2" | "lnk2" >
|
  < #REGEX: "regex" >
|
  < #NOT_REGEX: "nregex" >
|
  < #LIKE: "like" >
|
  < #NOT_LIKE: "nlike" >
|
  < #BETWEEN: "><" | "bw" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: (<SYMBOL>)(<LETTER>|<DIGIT>)+ | (<LETTER>|<DIGIT>)+ >
|
  < #SYMBOL: "$" >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}


/** Main production. */
ASTStart Start() #Start : {}
{
  (<WHERE>)? Expression() <EOF>
  { return jjtThis; }
}

/** Main production. */
ASTStart StartCommandLine() #Start : {}
{
  (<WHERE>)? Expression() "\n"
  { return jjtThis; }
}

/** An Expression. */
void Expression() :
{
  Token o;
}
{
  (
    UnaryExpression() ((o=<CONJ> { jjtThis.symbol(o.image); } UnaryExpression()) #Conj(2))*
  )
}

void UnaryExpression() : {}
{
   <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES> | RelationalExpression()
}

void RelationalExpression() #RelationalExpression :
{
  Token k;
  Token o;
  Token v;
  Token t;
}
{
  LOOKAHEAD(2)

  k=<IDENTIFIER> { jjtThis.key(k.image);}
  o=<UNARY_OPERATOR> { jjtThis.operator(o.image);}
  (v=<IDENTIFIER> { jjtThis.appendValue(v.image); } )+
  (<TIMESTAMP> (t=<IDENTIFIER> { jjtThis.timestamp(t.image);})+ )?
|
  k=<IDENTIFIER> { jjtThis.key(k.image);}
  o=<BINARY_OPERATOR> { jjtThis.operator(o.image);}
  v=<IDENTIFIER> { jjtThis.addValue(v.image); }
  v=<IDENTIFIER> { jjtThis.addValue(v.image); }
  (<TIMESTAMP> (t=<IDENTIFIER> { jjtThis.timestamp(t.image);})+ )?
}
