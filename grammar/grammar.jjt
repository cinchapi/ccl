/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.v2.generated;

/**
 * The Grammar generated by JavaCC
 */
public class Grammar {
    public static void main(String args[]) {
        System.out.println("Reading from standard input...");
        Grammar grammar = new Grammar(System.in);
        while (true) {
            try {
                ASTStart start = grammar.StartCommandLine();
                GrammarVisitor visitor = new GrammarDumpVisitor();
                start.jjtAccept(visitor, null);
                System.out.println("Thank you.");
            } catch (Exception e) {
                System.out.println("Oops.");
                System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN [IGNORE_CASE]: { < TIMESTAMP: "at" | "on" | "during" | "in" > }
TOKEN [IGNORE_CASE]: { < WHERE: "where" > }
TOKEN [IGNORE_CASE]: { < RESERVED_IDENTIFIER: "$id$" > }

TOKEN [IGNORE_CASE]:
{
  < CONJUNCTION: "and" | "&&" | "&" >
|
  < DISJUNCTION: "or" | "||" | "|" >
}

TOKEN [IGNORE_CASE]:
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> | <REGEX> | <NOT_REGEX> | <LIKE> | <NOT_LIKE> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < #EQUALS: "=" | "==" | "eq" | "equals" >
|
  < #NOT_EQUALS: "!=" | "ne" | "not_equals" >
|
  < #GREATER_THAN: ">" | "gt" | "greater_than">
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" | "greater_than_or_equals" >
|
  < #LESS_THAN: "<" | "lt" | "less_than">
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" | "less_than_or_equals" >
|
  < LINKS_TO: "->" | "lnks2" | "lnk2" | "links_to" >
|
  < #REGEX: "regex" >
|
  < #NOT_REGEX: "nregex" | "not_regex" >
|
  < #LIKE: "like" >
|
  < #NOT_LIKE: "nlike" | "not_like" >
|
  < #BETWEEN: "><" | "bw" | "between" >
}

TOKEN :
{
  < QUOTED_STRING : <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING> >
|
  < DOUBLE_QUOTED_STRING : "\"" ("\\" ~[] | ~["\"", "\\"])+ "\"" >
|
  < SINGLE_QUOTED_STRING : "'" ("\\" ~[] | ~["'", "\\"])+ "'" >
|
  < ESCAPED_META_ATTRIBUTE: <SIGNED_INTEGER>"\\"<POUND><ALPHANUMERIC> | <SIGNED_DECIMAL>"\\"<POUND><ALPHANUMERIC>  | <ALPHANUMERIC>"\\"<POUND><ALPHANUMERIC> >
|
  < META_ATTRIBUTE: <SIGNED_INTEGER><POUND><ALPHANUMERIC> | <SIGNED_DECIMAL><POUND><ALPHANUMERIC>  | <ALPHANUMERIC><POUND><ALPHANUMERIC> >
|
  < VALID_MISSING_META_ATTRIBUTE: <SIGNED_INTEGER><POUND> | <SIGNED_DECIMAL><POUND> | <ALPHANUMERIC><POUND> | <NON_ALPHANUMERIC_AND_ALPHANUMERIC><POUND> >
|
  < NUMERIC: (<DIGIT>)+ >
|
  < SIGNED_INTEGER : (("-" | "+")? (<DIGIT>)+) >
|
  < SIGNED_DECIMAL : (("-" | "+")?  (<DIGIT>)+<PERIOD>(<DIGIT>)+ ) >
|
  < ALPHANUMERIC: (<LETTER>|<DIGIT>)+ >
|
  < NON_ALPHANUMERIC_AND_ALPHANUMERIC: (<NON_ALPHANUMERIC>|<ALPHANUMERIC>)+ >
|
  < #POUND: "#" >
|
  < #NON_ALPHANUMERIC: ~["_","a"-"z","A"-"Z", "\n", "\t", "\r", " ", "(", ")", "="] >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #PERIOD: "." >
}

ASTStart StartCommandLine() #Start : {}
{
   (<WHERE>)? DisjunctionExpression() "\n"
   { return jjtThis; }
}

ASTStart generateAST() #Start : {}
{
   (<WHERE>)? DisjunctionExpression() <EOF>
   { return jjtThis; }
}

ASTStart generateSubAST() #Start : {}
{
   DisjunctionExpression()
   { return jjtThis; }
}

void DisjunctionExpression() : {}
{
  (
    ConjunctionExpression() ((<DISJUNCTION> ConjunctionExpression()) #Or(2))*
  )
}

void ConjunctionExpression() : {}
{
  (
    UnaryExpression() ((<CONJUNCTION> UnaryExpression()) #And(2))*
  )
}

void UnaryExpression() : {}
{
   <OPEN_PARENTHESES> DisjunctionExpression() <CLOSE_PARENTHESES> | RelationalExpression()
}

void RelationalExpression() #Expression :
{
    String key = null;
    String operator = null;
    String value1 = null;
    String value2 = null;
    String timestamp = null;
}
{
    key=Key()
      (
        operator=LinksToOperator() value1=LinksToValue() timestamp=Timestamp()
      |
        operator=UnaryOperator() value1=UnaryValue() timestamp=Timestamp()
      |
        operator=BinaryOperator() value1=BinaryValue() value2=BinaryValue() timestamp=Timestamp()
      ) { jjtThis.key(key);
          jjtThis.operator(operator);
          jjtThis.addValue(value1);
          if(value2 != null) jjtThis.addValue(value2);
          if(timestamp != null) jjtThis.timestamp(timestamp);
        }
}

String Key() :
{
  Token key;
}
{
  (
    (key=<META_ATTRIBUTE> | key=<RESERVED_IDENTIFIER> | key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC>)
    { return key.image; }
  )
}

String LinksToValue() :
{
  Token word;
}
{
  (word=<NUMERIC>)
  { return word.image; }
}

String UnaryValue() :
{
  Token word;
  String value = "";
}
{
  (
    ((word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC> | word=<META_ATTRIBUTE> | word=<ESCAPED_META_ATTRIBUTE> | word=<VALID_MISSING_META_ATTRIBUTE>) { value += (value.equals("")) ? word.image : " " + word.image; })+
    {
      return value.replace("\\@", "@");
    }
  |
    (word=<QUOTED_STRING>)
    { return word.image.replace("\\\"", "\""); }
  )
}

String BinaryValue() :
{
  Token word;
}
{
  (
    (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC> | word=<META_ATTRIBUTE> | word=<ESCAPED_META_ATTRIBUTE> | word=<VALID_MISSING_META_ATTRIBUTE>)
    {
      return word.image.replace("\\@", "@");
    }
  |
    (word=<QUOTED_STRING>)
    { return word.image.replace("\\\"", "\""); }
  )
}

String LinksToOperator() :
{
  Token operator;
}
{
  operator=<LINKS_TO> { return operator.image; }
}

String UnaryOperator() :
{
  Token operator;
}
{
  operator=<UNARY_OPERATOR> { return operator.image; }
}

String BinaryOperator() :
{
  Token operator;
}
{
  operator=<BINARY_OPERATOR> { return operator.image; }
}

String Timestamp() :
{
  Token word;
  String timestamp = "";
}
{
  (<TIMESTAMP> ((word=<QUOTED_STRING> | word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { timestamp += (timestamp.equals("")) ? word.image : " " + word.image; })+)?
  { return timestamp; }
}