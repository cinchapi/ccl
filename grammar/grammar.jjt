/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.v2.generated;

import com.cinchapi.ccl.SyntaxException;
import com.cinchapi.ccl.grammar.ConjunctionSymbol;
import com.cinchapi.ccl.grammar.ExplicitCclFunction;
import com.cinchapi.ccl.grammar.ExplicitRecordsFunction;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.grammar.ImplicitFunction;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ParenthesisSymbol;
import com.cinchapi.ccl.grammar.Symbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.common.base.AnyStrings;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;

/**
 * The Grammar generated by JavaCC
 */
public class Grammar {
    private List<Symbol> symbols = Lists.newArrayList();
    private Multimap<String, Object> data;
    private Function<String, Object> valueTransformFunction;
    private Function<String, Operator> operatorTransformFunction;

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction) {
        this(stream, null);
        this.data = null;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
    }

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                Multimap<String, Object> data) {
        this(stream, null);
        this.data = data;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
    }

    public Operator transformOperator(String token) {
        return operatorTransformFunction.apply(token);
    }

    public Object transformValue(String token) {
        return valueTransformFunction.apply(token);
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN [IGNORE_CASE]: { < TIMESTAMP: "at" | "on" | "during" | "in" > }
TOKEN [IGNORE_CASE]: { < WHERE: "where" > }
TOKEN [IGNORE_CASE]: { < RESERVED_IDENTIFIER: "$id$" > }

TOKEN [IGNORE_CASE]:
{
  < CONJUNCTION: "and" | "&&" | "&" >
|
  < DISJUNCTION: "or" | "||" | "|" >
}

TOKEN [IGNORE_CASE]:
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> | <REGEX> | <NOT_REGEX> | <LIKE> | <NOT_LIKE> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < #EQUALS: "=" | "==" | "eq" | "equals" >
|
  < #NOT_EQUALS: "!=" | "ne" | "not_equals" >
|
  < #GREATER_THAN: ">" | "gt" | "greater_than">
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" | "greater_than_or_equals" >
|
  < #LESS_THAN: "<" | "lt" | "less_than">
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" | "less_than_or_equals" >
|
  < LINKS_TO: "->" | "lnks2" | "lnk2" | "links_to" >
|
  < #REGEX: "regex" >
|
  < #NOT_REGEX: "nregex" | "not_regex" >
|
  < #LIKE: "like" >
|
  < #NOT_LIKE: "nlike" | "not_like" >
|
  < #BETWEEN: "><" | "bw" | "between" >
}

TOKEN :
{
  < QUOTED_STRING : <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING> >
|
  < DOUBLE_QUOTED_STRING : ("\"" ("\\" ~[] | ~["\"", "\\"])+ "\"") | ("“" ("\\" ~[] | ~["”", "\\"])+ "”") >
|
  < SINGLE_QUOTED_STRING : ("'" ("\\" ~[] | ~["'", "\\"])+ "'") | ("‘" ("\\" ~[] | ~["’", "\\"])+ "’") >
|
  < FUNCTION_ALPHANUMERIC : (<SIGNED_DECIMAL> | <ALPHANUMERIC>)+ ",">
|
  < SIGNED_DECIMAL : (("-")? ((<DIGIT>)+<PERIOD>(<DIGIT>)+ ))>
|
  < NUMERIC: (<DIGIT>)+ >
|
  < SIGNED_DECIMAL : (("-")? ( (<DIGIT>)+|(<DIGIT>)+<PERIOD>(<DIGIT>)+ ))>
|
  < ALPHANUMERIC: (<LETTER>|<DIGIT>)+ >
|
  < PERIOD_SEPARATED_STRING: (<SIGNED_DECIMAL> | <ALPHANUMERIC>) ("." (<SIGNED_DECIMAL> | <ALPHANUMERIC>))* >
|
  < NON_ALPHANUMERIC_AND_ALPHANUMERIC: (<NON_ALPHANUMERIC>|<ALPHANUMERIC>)+ >
|
  < #NON_ALPHANUMERIC: ~["_","a"-"z","A"-"Z", "\n", "\t", "\r", " ", "(", ")", "="] >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #PERIOD: "." >
}

List<Symbol> Start() :
{
   List<Symbol> symbols = Lists.newArrayList();
}
{
   (<WHERE>)? DisjunctionExpression(symbols) <EOF>
   { return symbols; }
}

List<Symbol> Ccl() :
{
   List<Symbol> symbols = Lists.newArrayList();
}
{
   DisjunctionExpression(symbols)
   { return symbols; }
}

void DisjunctionExpression(List<Symbol> symbols) : {}
{
  (
    ConjunctionExpression(symbols) (((<DISJUNCTION>) { symbols.add(ConjunctionSymbol.OR); } ConjunctionExpression(symbols)) )*
  )
}

void ConjunctionExpression(List<Symbol> symbols) : {}
{
  (
    UnaryExpression(symbols) (((<CONJUNCTION>) { symbols.add(ConjunctionSymbol.AND); } UnaryExpression(symbols)) )*
  )
}

void UnaryExpression(List<Symbol> symbols) : {}
{
   (<OPEN_PARENTHESES>) { symbols.add(ParenthesisSymbol.LEFT); } DisjunctionExpression(symbols) (<CLOSE_PARENTHESES>) { symbols.add(ParenthesisSymbol.RIGHT); } | RelationalExpression(symbols)
}

void RelationalExpression(List<Symbol> symbols) : {}
{
    Key(symbols)
      (
        UnaryOperator(symbols) UnaryValue(symbols) Timestamp(symbols)
      |
        BinaryOperator(symbols) BinaryValue(symbols) BinaryValue(symbols) Timestamp(symbols)
      )
}

void Key(List<Symbol> symbols) :
{
  Token f;
  Token k;
}
{
  (k=<SIGNED_DECIMAL> | k=<ALPHANUMERIC>)
  (
    <OPEN_PARENTHESES> f=<FUNCTION_ALPHANUMERIC> " ?" <CLOSE_PARENTHESES>
    { symbols.add(new FunctionKeySymbol(new ImplicitFunction(k.image, f.image.substring(0, f.image.length()-1))));}
  |
    { symbols.add(new KeySymbol(k.image)); }
  )
}

void UnaryValue(List<Symbol> symbols) :
{
  Token f;
  Token k;
  Token v;
  String value = "";
  List<String> records = Lists.newArrayList();
  List<Symbol> ccl;
}
{
  LOOKAHEAD(2)

  f=<ALPHANUMERIC> <OPEN_PARENTHESES> k=<FUNCTION_ALPHANUMERIC>
   (
     " ?" <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ImplicitFunction(f.image, k.image.substring(0, k.image.length()-1))));}
   |
     LOOKAHEAD(2)

     (v=<FUNCTION_ALPHANUMERIC> { records.add(v.image.substring(0, v.image.length()-1)); })*
     (v=<SIGNED_DECIMAL> | v=<ALPHANUMERIC>) { records.add(v.image);} <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ExplicitRecordsFunction(f.image, k.image.substring(0, k.image.length()-1), records)));}
   |
     ccl=Ccl() <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ExplicitCclFunction(f.image, k.image.substring(0, k.image.length()-1), ccl)));}
   )
|
  ( LOOKAHEAD(2) (v=<QUOTED_STRING> | v=<SIGNED_DECIMAL> | v=<ALPHANUMERIC> | v=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { value += (value.equals("")) ? v.image : " " + v.image; })+
  {
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }

    symbols.add(new ValueSymbol(transformValue(value)));
  }
}

void BinaryValue(List<Symbol> symbols) :
{
  Token f;
  Token k;
  Token v;
  String value = "";
  List<String> records = Lists.newArrayList();
  List<Symbol> ccl;
}
{
  LOOKAHEAD(2)

  f=<ALPHANUMERIC> <OPEN_PARENTHESES> k=<FUNCTION_ALPHANUMERIC>
   (
     " ?" <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ImplicitFunction(f.image, k.image.substring(0, k.image.length()-1))));}
   |
     LOOKAHEAD(2)

     (v=<FUNCTION_ALPHANUMERIC> { records.add(v.image.substring(0, v.image.length()-1)); })*
     (v=<SIGNED_DECIMAL> | v=<ALPHANUMERIC>) { records.add(v.image);} <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ExplicitRecordsFunction(f.image, k.image.substring(0, k.image.length()-1), records)));}
   |
     ccl=Ccl() <CLOSE_PARENTHESES>
     { symbols.add(new FunctionValueSymbol(new ExplicitCclFunction(f.image, k.image.substring(0, k.image.length()-1), ccl)));}
   )
|
  (v=<QUOTED_STRING> | v=<SIGNED_DECIMAL> | v=<ALPHANUMERIC> | v=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>)
  {
    value = v.image;
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }

    symbols.add(new ValueSymbol(transformValue(value)));
  }
}

void UnaryOperator(List<Symbol> symbols) :
{
  Token o;
}
{
  o=<UNARY_OPERATOR> { symbols.add(new OperatorSymbol(transformOperator(o.image))); }
}

void BinaryOperator(List<Symbol> symbols) :
{
  Token o;
}
{
  o=<BINARY_OPERATOR> { symbols.add(new OperatorSymbol(transformOperator(o.image))); }
}

void Timestamp(List<Symbol> symbols) :
{
  Token t;
  String ts = "";
}
{
  (<TIMESTAMP> ((t=<QUOTED_STRING> | t=<SIGNED_DECIMAL> | t=<ALPHANUMERIC> | t=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { ts += (ts.equals("")) ? t.image : " " + t.image; })+
  { symbols.add(new TimestampSymbol(NaturalLanguage.parseMicros(ts))); })?
}