/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.generated;

import com.cinchapi.ccl.SyntaxException;
import com.cinchapi.ccl.grammar.DirectionSymbol;
import com.cinchapi.ccl.grammar.FunctionTokenSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.ValueTokenSymbol;
import com.cinchapi.ccl.type.function.KeyCclFunction;
import com.cinchapi.ccl.type.function.KeyRecordsFunction;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.type.function.ImplicitKeyRecordFunction;
import com.cinchapi.ccl.type.function.IndexFunction;
import com.cinchapi.ccl.grammar.NavigationKeySymbol;
import com.cinchapi.ccl.grammar.KeyTokenSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.OrderComponentSymbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.PageSymbol;
import com.cinchapi.ccl.grammar.OrderSymbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.common.base.AnyStrings;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;

/**
 * The Grammar generated by JavaCC
 */
@SuppressWarnings({"unused", "rawtypes"})
public class Grammar {
    private Multimap<String, Object> data;
    private Function<String, Object> valueTransformFunction;
    private Function<String, Operator> operatorTransformFunction;
    private GrammarVisitor visitor;

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = null;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                Multimap<String, Object> data,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = data;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Operator transformOperator(String token) {
        return operatorTransformFunction.apply(token);
    }

    public Object transformValue(String token) {
        return valueTransformFunction.apply(token);
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN [IGNORE_CASE]: { < TIMESTAMP: "at" | "on" | "during" | "in" > }
TOKEN [IGNORE_CASE]: { < WHERE: "where" > }
TOKEN [IGNORE_CASE]: { < RESERVED_IDENTIFIER: "$id$" > }

TOKEN [IGNORE_CASE]:
{
  < CONJUNCTION: "and" | "&&" | "&" >
|
  < DISJUNCTION: "or" | "||" >
}

TOKEN [IGNORE_CASE]:
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < OPEN_ANGLE_BRACKET : "<" >
|
  < CLOSE_ANGLE_BRACKET : ">" >
|
  < #EQUALS: "=" | "==" | "eq" | "equals" >
|
  < #NOT_EQUALS: "!=" | "ne" | "not_equals" >
|
  < #GREATER_THAN: "gt" | "greater_than">
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" | "greater_than_or_equals" >
|
  < #LESS_THAN: "lt" | "less_than">
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" | "less_than_or_equals" >
|
  < LINKS_TO: "->" | "lnks2" | "lnk2" | "links_to" >
|
  < REGEX: "regex" >
|
  < NOT_REGEX: "nregex" | "not_regex" >
|
  < LIKE: "like" >
|
  < NOT_LIKE: "nlike" | "not_like" >
|
  < #BETWEEN: "><" | "bw" | "between" >
|
  < PAGE : "page" >
|
  < SIZE : "size" >
|
  < ORDER : "order by" >
|
  < ASC : "asc" >
|
  < DESC : "desc" >
}

TOKEN :
{
  < PIPE : "|" >
|
  < QUOTED_STRING : <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING> >
|
  < DOUBLE_QUOTED_STRING : ("\"" ("\\" ~[] | ~["\"", "\\"])+ "\"") | ("“" ("\\" ~[] | ~["”", "\\"])+ "”") >
|
  < SINGLE_QUOTED_STRING : ("'" ("\\" ~[] | ~["'", "\\"])+ "'") | ("‘" ("\\" ~[] | ~["’", "\\"])+ "’") | ("`" ("\\" ~[] | ~["`", "\\"])+ "`") >
|
  < NUMERIC: (<DIGIT>)+ >
|
  < COMMA : "," >
|
  < SIGNED_INTEGER : (("-" | "+")? (<DIGIT>)+) >
|
  < SIGNED_DECIMAL : (("-" | "+")?  (<DIGIT>)+<PERIOD>(<DIGIT>)+ ) >
|
  < ALPHANUMERIC: (<LETTER>|<DIGIT>)+ >
|
  < PERIOD_SEPARATED_STRING: (<SIGNED_DECIMAL> | <ALPHANUMERIC>) ("." (<SIGNED_DECIMAL> | <ALPHANUMERIC>))* >
|
  < NON_ALPHANUMERIC_AND_ALPHANUMERIC: (<NON_ALPHANUMERIC>|<ALPHANUMERIC>)+ >
|
  < #NON_ALPHANUMERIC: ~[",", "_","a"-"z","A"-"Z", "\n", "\t", "\r", " ", "(", ")", "="] >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #PERIOD: "." >
}

ASTStart StartCommandLine() #Start : {}
{
   ( LOOKAHEAD(4)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? "\n"
   |
     Page() "\n"
   |
     Order() "\n"
   |
     Function() "\n"
   )
   { return jjtThis; }
}

ASTStart generateAST() #Start : {}
{
   ( LOOKAHEAD(4)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? <EOF>
   |
     Page() <EOF>
   |
     Order() <EOF>
   |
     Function() <EOF>
   )
   { return jjtThis; }
}

ASTStart generateSubAST() #Start : {}
{
   DisjunctionExpression()
   { return jjtThis; }
}

void DisjunctionExpression() : {}
{
  (
    ConjunctionExpression() (((<DISJUNCTION>) ConjunctionExpression()) #Or(2) )*
  )
}

void ConjunctionExpression() : {}
{
  (
    UnaryExpression() (((<CONJUNCTION>) UnaryExpression()) #And(2) )*
  )
}

void UnaryExpression() : {}
{
   (<OPEN_PARENTHESES>) DisjunctionExpression() (<CLOSE_PARENTHESES>) | RelationalExpression()
}

void RelationalExpression() #Expression :
{
    KeyTokenSymbol key = null;
    OperatorSymbol operator = null;
    ValueTokenSymbol value1 = null;
    ValueTokenSymbol value2 = null;
    TimestampSymbol timestamp = null;
}
{
    key=Key()
      (
        operator=LinksToOperator() value1=LinksToValue() timestamp=Timestamp()
      |
        operator=RegexBasedOperator() value1=RegexValue() timestamp=Timestamp()
      |
        operator=UnaryOperator() value1=UnaryValue() timestamp=Timestamp()
      |
        operator=BinaryOperator() value1=BinaryValue() value2=BinaryValue() timestamp=Timestamp()
      ) { jjtThis.key(key);
          jjtThis.operator(operator);
          jjtThis.addValue(value1);
          if(value2 != null) jjtThis.addValue(value2);
          if(timestamp != null) jjtThis.timestamp(timestamp);
        }
}

KeyTokenSymbol Key() :
{
  FunctionKeySymbol function;
  Token key;
}
{
  (
    LOOKAHEAD(2)

    (function=KeyFunction())
    { return function; }
  |
    (key=<RESERVED_IDENTIFIER> | key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC>)
    { return new KeySymbol(key.image); }
  |
    (key=<PERIOD_SEPARATED_STRING>)
    { return new NavigationKeySymbol(key.image); }
  )
}

ValueTokenSymbol UnaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  ( LOOKAHEAD(2) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>) { value += (value.equals("")) ? word.image : " " + word.image; })+
  {
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol LinksToValue() :
{
  Token word;
}
{
  (word=<NUMERIC>)
  { return new ValueSymbol(transformValue(word.image)); }
}

ValueTokenSymbol RegexValue() :
{
  Token word;
  String value = "";
}
{
    (LOOKAHEAD(3) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>  | word="(" | word=")" | word="_" | word="=") { value += word.image; })+
    { return new ValueSymbol(transformValue(value)); }
  |
    (word=<QUOTED_STRING>)
    { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol BinaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>)
  {
    value = word.image;
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

OperatorSymbol LinksToOperator() :
{
  Token operator;
}
{
  operator=<LINKS_TO> { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol RegexBasedOperator() :
{
  Token operator;
}
{
  (operator=<REGEX> | operator=<NOT_REGEX> | operator=<LIKE> | operator =<NOT_LIKE>) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol UnaryOperator() :
{
  Token operator;
}
{
  (operator=<UNARY_OPERATOR> | operator=<OPEN_ANGLE_BRACKET> | operator=<CLOSE_ANGLE_BRACKET> ) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol BinaryOperator() :
{
  Token operator;
}
{
  operator=<BINARY_OPERATOR> { return new OperatorSymbol(transformOperator(operator.image)); }
}

TimestampSymbol Timestamp() :
{
  Token word;
  String timestamp = "";
}
{
  (<TIMESTAMP> (LOOKAHEAD(2) (word=<QUOTED_STRING> | word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { timestamp += (timestamp.equals("")) ? word.image : " " + word.image; })+
  { return new TimestampSymbol(NaturalLanguage.parseMicros(timestamp)); })?
  { return null; }
}

void Page() #Page :
{
  String number = null;
  String size = null;
}
{
  (
    number=Number() (size=Size())?
  |
    size=Size() (number=Number())?
  )
  { jjtThis.page(new PageSymbol(number != null ? Integer.parseInt(number) : null, size != null ? Integer.parseInt(size) : null)); }
}

String Number() :
{
   Token number;
}
{
  (
     (<PAGE> number=<NUMERIC>)
     { return number.image; }
  )
}

String Size() :
{
   Token size;
}
{
  (
     (<SIZE> size=<NUMERIC>)
     { return size.image; }
  )
}

void Order() #Order :
{
    OrderSymbol order = new OrderSymbol();
    OrderComponentSymbol orderComponent;
}
{
  (<ORDER>
  (orderComponent=OrderClause()
      { order.add(orderComponent); }
    (<COMMA> orderComponent=OrderClause()
      { order.add(orderComponent); })*))
  { jjtThis.order(order); }
}

OrderComponentSymbol OrderClause() :
{
    KeyTokenSymbol key;
    TimestampSymbol timestamp = null;
    DirectionSymbol direction = null;
}
{
  ((
    direction=SymbolicDirection() key=Key()
  |
    key=Key() (direction=WordDirection())?
  )
  timestamp=Timestamp())
  {
      if(direction != null) {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp, direction);
          }
          else {
              return new OrderComponentSymbol(key, direction);
          }
      }
      else {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp,
                  DirectionSymbol.ASCENDING);
          }
          else {
              return new OrderComponentSymbol(key,
                  DirectionSymbol.ASCENDING);
          }
      }
  }
}

DirectionSymbol SymbolicDirection() :
{
   Token direction;
}
{
  (
      direction=<OPEN_ANGLE_BRACKET>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<CLOSE_ANGLE_BRACKET>
      { return DirectionSymbol.DESCENDING; }
  )
}

DirectionSymbol WordDirection() :
{
   Token direction;
}
{
  (
      direction=<ASC>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<DESC>
      { return DirectionSymbol.DESCENDING; }
  )
}

void Function() #Function :
{
    FunctionTokenSymbol function;
}
{
  ( LOOKAHEAD(2)
    function = KeyFunction()
  |
    function = ValueFunction()
  )
  { jjtThis.function(function);}
}

FunctionKeySymbol KeyFunction() :
{
  Token key;
  Token function;
}
{
   (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <PIPE> function=<ALPHANUMERIC>
   { return new FunctionKeySymbol(new ImplicitKeyRecordFunction(function.image, key.image.substring(0, key.image.length())));}
}

FunctionValueSymbol ValueFunction() :
{
  Token function;
  Token key;
  Token word;
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  function=<ALPHANUMERIC> <OPEN_PARENTHESES>
   (
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <CLOSE_PARENTHESES>
     { return new FunctionValueSymbol(new IndexFunction(function.image, key.image));}
   |
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>)
     (<COMMA> (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image); })+ <CLOSE_PARENTHESES>
     { return new FunctionValueSymbol(new KeyRecordsFunction(function.image, key.image, records));}
   |
     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <COMMA> ccl=generateSubAST() <CLOSE_PARENTHESES>
     {
        AbstractSyntaxTree tree = (AbstractSyntaxTree) ccl.jjtAccept(visitor, null);

        return new FunctionValueSymbol(new KeyCclFunction(function.image, key.image, tree));}
   )
}