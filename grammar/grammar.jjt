/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.generated;

import com.cinchapi.ccl.SyntaxException;
import com.cinchapi.ccl.grammar.DirectionSymbol;
import com.cinchapi.ccl.grammar.FunctionTokenSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.ValueTokenSymbol;
import com.cinchapi.ccl.grammar.command.*;
import com.cinchapi.ccl.type.function.KeyConditionFunction;
import com.cinchapi.ccl.type.function.KeyRecordsFunction;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.type.function.ImplicitKeyRecordFunction;
import com.cinchapi.ccl.type.function.IndexFunction;
import com.cinchapi.ccl.grammar.NavigationKeySymbol;
import com.cinchapi.ccl.grammar.KeyTokenSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.OrderComponentSymbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.PageSymbol;
import com.cinchapi.ccl.grammar.OrderSymbol;
import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.ConditionTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.common.base.AnyStrings;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;

/**
 * The Grammar generated by JavaCC
 */
@SuppressWarnings({"unused", "rawtypes"})
public class Grammar {
    private Multimap<String, Object> data;
    private Function<String, Object> valueTransformFunction;
    private Function<String, Operator> operatorTransformFunction;
    private GrammarVisitor visitor;

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = null;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                Multimap<String, Object> data,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = data;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Operator transformOperator(String token) {
        return operatorTransformFunction.apply(token);
    }

    public Object transformValue(String token) {
        return valueTransformFunction.apply(token);
    }

    private boolean isValidJson(String json) {
        // Basic JSON validation
        int braceCount = 0;
        for(char c : json.toCharArray()) {
            if(c == '{') braceCount++;
            if(c == '}') braceCount--;
            if(braceCount < 0) return false;
        }
        return braceCount == 0;
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

// Token definitions
TOKEN [IGNORE_CASE] : {
  // Data modification commands
  < ADD: "add" >
| < SET: "set" >
| < REMOVE: "remove" >
| < CLEAR: "clear" >
| < VERIFY_AND_SWAP: "verifyAndSwap" | "verify_and_swap" >
| < VERIFY_OR_SET: "verifyOrSet" | "verify_or_set" >

  // Record operations
| < INSERT: "insert" >

  // Link operations
| < LINK: "link" >
| < UNLINK: "unlink" >

  // Query operations
| < SELECT: "select" >
| < GET: "get" >
| < FIND: "find" >
| < DESCRIBE: "describe" >
| < VERIFY: "verify" >
| < SEARCH: "search" >
| < BROWSE: "browse" >
| < CHRONOLOGIZE: "chronologize" >
| < DIFF: "diff" >
| < INVENTORY: "inventory" >
| < JSONIFY: "jsonify" >
| < NAVIGATE: "navigate" >
| < RECONCILE: "reconcile" >
| < REVIEW: "review" >
| < TRACE: "trace" >
| < CALCULATE: "calculate" >

  // Transaction operations
| < STAGE: "stage" >
| < COMMIT: "commit" >
| < ABORT: "abort" >

  // Revert operation
| < REVERT: "revert" >

  // Other keywords
| < IN: "in" >
| < INTO: "into" >
| < FROM: "from" >
| < TO: "to" >
| < AS_OF: "as of" >
| < AS: "as" >
| < FOR: "for" >
| < WITH: "with" >
| < OPEN_BRACE : "{" >
| < CLOSE_BRACE : "}" >
| < COLON : ":" >
}


TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN : { < OPEN_BRACKET : "[" > }
TOKEN : { < CLOSE_BRACKET : "]" > }
TOKEN [IGNORE_CASE]: {< TIMESTAMP: "at" | "on" | "during" > }
TOKEN [IGNORE_CASE]: { < WHERE: "where" > }
TOKEN [IGNORE_CASE]: { < RESERVED_IDENTIFIER: "$id$" > }

TOKEN [IGNORE_CASE]:
{
  < CONJUNCTION: "and" | "&&" | "&" >
|
  < DISJUNCTION: "or" | "||" >
}

TOKEN [IGNORE_CASE]:
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < OPEN_ANGLE_BRACKET : "<" >
|
  < CLOSE_ANGLE_BRACKET : ">" >
|
  < #EQUALS: "=" | "==" | "eq" | "equals" >
|
  < #NOT_EQUALS: "!=" | "ne" | "not_equals" >
|
  < #GREATER_THAN: "gt" | "greater_than">
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" | "greater_than_or_equals" >
|
  < #LESS_THAN: "lt" | "less_than">
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" | "less_than_or_equals" >
|
  < LINKS_TO: "->" | "lnks2" | "lnk2" | "links_to" >
|
  < REGEX: "regex" >
|
  < NOT_REGEX: "nregex" | "not_regex" >
|
  < LIKE: "like" >
|
  < NOT_LIKE: "nlike" | "not_like" >
|
  < #BETWEEN: "><" | "bw" | "between" >
|
  < PAGE : "page" >
|
  < SIZE : "size" >
|
  < ORDER : "order by" >
|
  < ASC : "asc" >
|
  < DESC : "desc" >
}

TOKEN :
{
  < PIPE : "|" >
|
  < QUOTED_STRING : <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING> >
|
  < DOUBLE_QUOTED_STRING : ("\"" ("\\" ~[] | ~["\"", "\\"])+ "\"") | ("“" ("\\" ~[] | ~["”", "\\"])+ "”") >
|
  < SINGLE_QUOTED_STRING : ("'" ("\\" ~[] | ~["'", "\\"])+ "'") | ("‘" ("\\" ~[] | ~["’", "\\"])+ "’") | ("`" ("\\" ~[] | ~["`", "\\"])+ "`") >
|
  < NUMERIC: (<DIGIT>)+ >
|
  < COMMA : "," >
|
  < SIGNED_INTEGER : (("-" | "+")? (<DIGIT>)+) >
|
  < SIGNED_DECIMAL : (("-" | "+")?  (<DIGIT>)+<PERIOD>(<DIGIT>)+ ) >
|
  < ALPHANUMERIC: (<LETTER>|<DIGIT>)+ >
|
  < PERIOD_SEPARATED_STRING: (<SIGNED_DECIMAL> | <ALPHANUMERIC>) ("." (<SIGNED_DECIMAL> | <ALPHANUMERIC>))* >
|
  < NON_ALPHANUMERIC_AND_ALPHANUMERIC: (<NON_ALPHANUMERIC>|<ALPHANUMERIC>)+ >
|
  < #NON_ALPHANUMERIC: ~[",", "_","a"-"z","A"-"Z", "\n", "\t", "\r", " ", "(", ")", "[", "]", "="] >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #PERIOD: "." >
}

ASTStart StartCommandLine() #Start : {}
{
   (
     Command() "\n"
   |
     LOOKAHEAD(4)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? "\n"
   |
     Page() "\n"
   |
     Order() "\n"
   |
     Function() "\n"
   )
   { return jjtThis; }
}

ASTStart generateAST() #Start : {}
{
   (
     Command() <EOF>
   |
     LOOKAHEAD(4)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? <EOF>
   |
     Page() <EOF>
   |
     Order() <EOF>
   |
     Function() <EOF>
   )
   { return jjtThis; }
}

ASTStart generateSubAST() #Start : {}
{
   DisjunctionExpression()
   { return jjtThis; }
}

void DisjunctionExpression() : {}
{
  (
    ConjunctionExpression() (((<DISJUNCTION>) ConjunctionExpression()) #Or(2) )*
  )
}

void ConjunctionExpression() : {}
{
  (
    UnaryExpression() (((<CONJUNCTION>) UnaryExpression()) #And(2) )*
  )
}

void UnaryExpression() : {}
{
   (<OPEN_PARENTHESES>) DisjunctionExpression() (<CLOSE_PARENTHESES>) | RelationalExpression()
}

void RelationalExpression() #Expression :
{
    KeyTokenSymbol key = null;
    OperatorSymbol operator = null;
    ValueTokenSymbol value1 = null;
    ValueTokenSymbol value2 = null;
    TimestampSymbol timestamp = null;
}
{
    key=Key()
      (
        operator=LinksToOperator() value1=LinksToValue() (LOOKAHEAD(2) timestamp=Timestamp())?
      |
        operator=RegexBasedOperator() value1=RegexValue() (LOOKAHEAD(2) timestamp=Timestamp())?
      |
        operator=UnaryOperator() value1=UnaryValue() (LOOKAHEAD(2) timestamp=Timestamp())?
      |
        operator=BinaryOperator() value1=BinaryValue() value2=BinaryValue() (LOOKAHEAD(2) timestamp=Timestamp())?
      ) { jjtThis.key(key);
          jjtThis.operator(operator);
          jjtThis.addValue(value1);
          if(value2 != null) jjtThis.addValue(value2);
          if(timestamp != null) jjtThis.timestamp(timestamp);
        }
}

KeyTokenSymbol Key() :
{
  FunctionKeySymbol function;
  Token key;
}
{
  (
    LOOKAHEAD(2)

    (function=KeyFunction())
    { return function; }
  |
    (key=<RESERVED_IDENTIFIER> | key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC>)
    { return new KeySymbol(key.image); }
  |
    (key=<PERIOD_SEPARATED_STRING>)
    { return new NavigationKeySymbol(key.image); }
  )
}

ValueTokenSymbol UnaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  ( LOOKAHEAD(2) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>) { value += (value.equals("")) ? word.image : " " + word.image; })+
  {
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol LinksToValue() :
{
  Token word;
}
{
  (word=<NUMERIC>)
  { return new ValueSymbol(transformValue(word.image)); }
}

ValueTokenSymbol RegexValue() :
{
  Token word;
  String value = "";

}
{
    <OPEN_PARENTHESES> (LOOKAHEAD(4) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>  | word="_" | word="=")
    {
        if (value.equals("") |
            value.endsWith("(") | word.image.equals(")") |
            value.endsWith("=") | word.image.equals("=") |
            value.endsWith("_") | word.image.equals("_")) {
            value += word.image;
        }
        else {
            value += " " + word.image;
        }
    })+ <CLOSE_PARENTHESES>
    { return new ValueSymbol(transformValue("(" + value + ")")); }
  |
    (LOOKAHEAD(3) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>  | word="_" | word="=")
    {
        if (value.equals("") |
            value.endsWith("(") | word.image.equals(")") |
            value.endsWith("=") | word.image.equals("=") |
            value.endsWith("_") | word.image.equals("_")) {
            value += word.image;
        }
        else {
            value += " " + word.image;
        }
    })+
    { return new ValueSymbol(transformValue(value)); }
  |
    (word=<QUOTED_STRING>)
    { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol BinaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>)
  {
    value = word.image;
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

OperatorSymbol LinksToOperator() :
{
  Token operator;
}
{
  operator=<LINKS_TO> { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol RegexBasedOperator() :
{
  Token operator;
}
{
  (operator=<REGEX> | operator=<NOT_REGEX> | operator=<LIKE> | operator =<NOT_LIKE>) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol UnaryOperator() :
{
  Token operator;
}
{
  (operator=<UNARY_OPERATOR> | operator=<OPEN_ANGLE_BRACKET> | operator=<CLOSE_ANGLE_BRACKET> ) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol BinaryOperator() :
{
  Token operator;
}
{
  operator=<BINARY_OPERATOR> { return new OperatorSymbol(transformOperator(operator.image)); }
}

TimestampSymbol Timestamp() :
{
  Token word;
  String timestamp = "";
}
{
  (<TIMESTAMP> | <IN>) (LOOKAHEAD(2) (word=<QUOTED_STRING> | word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { timestamp += (timestamp.equals("")) ? word.image : " " + word.image; })+
  { return new TimestampSymbol(NaturalLanguage.parseMicros(timestamp)); }
}

TimestampSymbol TimestampReadCommand() :
{
  Token word;
  String timestamp = "";
}
{
  (<TIMESTAMP> | <IN> | <AS_OF>) (LOOKAHEAD(2) (word=<QUOTED_STRING> | word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { timestamp += (timestamp.equals("")) ? word.image : " " + word.image; })+
  { return new TimestampSymbol(NaturalLanguage.parseMicros(timestamp)); }
}

void Page() #Page :
{
  String number = null;
  String size = null;
}
{
  (
    number=Number() (size=Size())?
  |
    size=Size() (number=Number())?
  )
  { jjtThis.page(new PageSymbol(number != null ? Integer.parseInt(number) : null, size != null ? Integer.parseInt(size) : null)); }
}

String Number() :
{
   Token number;
}
{
  (
     (<PAGE> number=<NUMERIC>)
     { return number.image; }
  )
}

String Size() :
{
   Token size;
}
{
  (
     (<SIZE> size=<NUMERIC>)
     { return size.image; }
  )
}

void Order() #Order :
{
    OrderSymbol order = new OrderSymbol();
    OrderComponentSymbol orderComponent;
}
{
  (<ORDER>
  (orderComponent=OrderClause()
      { order.add(orderComponent); }
    (<COMMA> orderComponent=OrderClause()
      { order.add(orderComponent); })*))
  { jjtThis.order(order); }
}

OrderComponentSymbol OrderClause() :
{
    KeyTokenSymbol key;
    TimestampSymbol timestamp = null;
    DirectionSymbol direction = null;
}
{

  ((
    direction=SymbolicDirection() key=Key()
  |
    key=Key() (direction=WordDirection())?
  )
  (timestamp=Timestamp())?)
  {
      if(direction != null) {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp, direction);
          }
          else {
              return new OrderComponentSymbol(key, direction);
          }
      }
      else {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp,
                  DirectionSymbol.ASCENDING);
          }
          else {
              return new OrderComponentSymbol(key,
                  DirectionSymbol.ASCENDING);
          }
      }
  }
}

DirectionSymbol SymbolicDirection() :
{
   Token direction;
}
{
  (
      direction=<OPEN_ANGLE_BRACKET>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<CLOSE_ANGLE_BRACKET>
      { return DirectionSymbol.DESCENDING; }
  )
}

DirectionSymbol WordDirection() :
{
   Token direction;
}
{
  (
      direction=<ASC>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<DESC>
      { return DirectionSymbol.DESCENDING; }
  )
}

void Function() #Function :
{
    FunctionTokenSymbol function;
}
{
  ( LOOKAHEAD(2)
    function = KeyFunction()
  |
    function = ValueFunction()
  )
  { jjtThis.function(function);}
}

FunctionKeySymbol KeyFunction() :
{
  Token key;
  Token function;
}
{
   (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <PIPE> function=<ALPHANUMERIC>
   { return new FunctionKeySymbol(new ImplicitKeyRecordFunction(function.image, key.image.substring(0, key.image.length())));}
}

FunctionValueSymbol ValueFunction() :
{
  Token function;
  Token key;
  Token word;
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
  TimestampSymbol timestamp = null;
}
{
  function=<ALPHANUMERIC> <OPEN_PARENTHESES>
   (
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>)
     (
         <CLOSE_PARENTHESES>
         { return new FunctionValueSymbol(new IndexFunction(function.image, key.image));}
     |
         <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
         { return new FunctionValueSymbol(new IndexFunction(function.image, key.image, timestamp.timestamp()));}
     )
   |
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <COMMA>
     (
        (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image);}
        (<COMMA> (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image); })* <CLOSE_PARENTHESES>
        { return new FunctionValueSymbol(new KeyRecordsFunction(function.image, key.image, records));}
     |
        <OPEN_BRACKET>
        (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image);}
        (<COMMA> (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image); })*
        <CLOSE_BRACKET> <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
        { return new FunctionValueSymbol(new KeyRecordsFunction(function.image, key.image, records, timestamp.timestamp()));}
     )
   |
     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <COMMA> ccl=generateSubAST()
     (
        <CLOSE_PARENTHESES>
        {
          ConditionTree tree = (ConditionTree) ccl.jjtAccept(visitor, null);
          return new FunctionValueSymbol(new KeyConditionFunction(function.image, key.image, tree));
        }
     |
        <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
        {
          ConditionTree tree = (ConditionTree) ccl.jjtAccept(visitor, null);
          return new FunctionValueSymbol(new KeyConditionFunction(function.image, key.image, tree, timestamp.timestamp()));
        }
     )
   )
}

void Command() #Command : {
    CommandSymbol cmd;
}
{
    (
        cmd = DataModificationOperations()
      |
        cmd = RecordOperations()
      |
        cmd = LinkOperations()
      |
        cmd = QueryOperations()
      |
        cmd = TransactionOperations()
      |
        cmd = RevertCommand()
    )
    { jjtThis.command(cmd); }
}

CommandSymbol DataModificationOperations() : {
    CommandSymbol cmd;
}
{
    (
        cmd = AddCommand()
      |
        cmd = SetCommand()
      |
        cmd = RemoveCommand()
      |
        cmd = ClearCommand()
      |
        cmd = VerifyAndSwapCommand()
      |
        cmd = VerifyOrSetCommand()
    )
    { return cmd; }
}

CommandSymbol AddCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record = null;
    Collection records = null;
}
{
    <ADD> key=Key() <AS> value=UnaryValue()
    (
        (<IN>
        (
            record=<NUMERIC>
            { return new AddSymbol(key, value, Long.parseLong(record.image)); }
          |
            records=RecordCollection()
            { return new AddSymbol(key, value, records); }
        ))?
    )
    { return new AddSymbol(key, value); }
}

CommandSymbol SetCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
}
{
    <SET> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    { return new SetSymbol(key, value, Long.parseLong(record.image)); }
}

CommandSymbol RemoveCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value = null;
    Token record;
    Collection records = null;
}
{
    <REMOVE> key=Key() (<AS> value=UnaryValue())? (<FROM> | <IN>)
    (
        record=<NUMERIC> { return new RemoveSymbol(key, value, Long.parseLong(record.image)); }
      |
        records=RecordCollection() { return new RemoveSymbol(key, value, records); }
    )
}

CommandSymbol ClearCommand() : {
    KeyTokenSymbol<?> key = null;
    Collection<KeyTokenSymbol<?>> keys = null;
    Token record = null;
    Collection records = null;
}
{
    <CLEAR>
    (
        LOOKAHEAD(2)
        record=<NUMERIC>
        { return new ClearSymbol((KeyTokenSymbol<?>)null, Long.parseLong(record.image)); }
      |
        LOOKAHEAD(3)
        records=RecordCollection()
        { return new ClearSymbol((KeyTokenSymbol<?>)null, records); }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> record=<NUMERIC>
        { return new ClearSymbol(key, Long.parseLong(record.image)); }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> records=RecordCollection()
        { return new ClearSymbol(key, records); }
      |
        LOOKAHEAD(7)
        keys=KeyCollection() <FROM> record=<NUMERIC>
        { return new ClearSymbol(keys, Long.parseLong(record.image)); }
      |
        LOOKAHEAD(7)
        keys=KeyCollection() <FROM> records=RecordCollection()
        { return new ClearSymbol(keys, records); }
    )
}

CommandSymbol VerifyAndSwapCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> expected;
    ValueTokenSymbol<?> replacement;
    Token record;
}
{
    <VERIFY_AND_SWAP> key=Key() <AS> expected=UnaryValue() <IN> record=<NUMERIC>
    <WITH> replacement=UnaryValue()
    { return new VerifyAndSwapSymbol(key, expected, replacement, Long.parseLong(record.image)); }
}

CommandSymbol VerifyOrSetCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
}
{
    <VERIFY_OR_SET> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    { return new VerifyOrSetSymbol(key, value, Long.parseLong(record.image)); }
}

CommandSymbol RecordOperations() : {
    CommandSymbol cmd;
}
{
    cmd = InsertCommand()
    { return cmd; }
}

CommandSymbol InsertCommand() : {
    String json;
    Token record = null;
    Collection records = null;
}
{
    <INSERT> json=JsonObject()
    {
        // Basic JSON validation
        if(!isValidJson(json)) {
            throw new ParseException("Malformed JSON");
        }
    }
    (
        (<IN> | <INTO>)
        (
            record=<NUMERIC>
            { return new InsertSymbol(json, Long.parseLong(record.image)); }
          |
            records=RecordCollection()
            { return new InsertSymbol(json, records); }
        )
    )?
    { return new InsertSymbol(json); }
}

CommandSymbol LinkOperations() : {
    CommandSymbol cmd;
}
{
    (
        cmd = LinkCommand()
      |
        cmd = UnlinkCommand()
    )
    { return cmd; }
}

CommandSymbol LinkCommand() : {
    KeyTokenSymbol<?> key;
    Token source;
    Token destination;
    Collection destinations = null;
}
{
    <LINK> key=Key() <FROM> source=<NUMERIC> <TO>
    (
        destination=<NUMERIC>
        {
            Collection dest = new ArrayList();
            dest.add(Long.parseLong(destination.image));
            return new LinkSymbol(key, Long.parseLong(source.image), dest);
        }
      |
        destinations=RecordCollection()
        { return new LinkSymbol(key, Long.parseLong(source.image), destinations); }
    )
}

CommandSymbol UnlinkCommand() : {
    KeyTokenSymbol<?> key;
    Token source;
    Token destination;
    Collection destinations = null;
}
{
    <UNLINK> key=Key() <FROM> source=<NUMERIC> <TO>
    (
        destination=<NUMERIC>
        {
            Collection dest = new ArrayList();
            dest.add(Long.parseLong(destination.image));
            return new UnlinkSymbol(key, Long.parseLong(source.image), dest);
        }
      |
        destinations=RecordCollection()
        { return new UnlinkSymbol(key, Long.parseLong(source.image), destinations); }
    )
}

CommandSymbol QueryOperations() : {
    CommandSymbol cmd;
}
{
    (
        cmd = SelectCommand()
      |
        cmd = GetCommand()
      |
        cmd = FindCommand()
      |
        cmd = DescribeCommand()
      |
        cmd = VerifyCommand()
      |
        cmd = SearchCommand()
      |
        cmd = BrowseCommand()
      |
        cmd = ChronologizeCommand()
      |
        cmd = DiffCommand()
      |
        cmd = InventoryCommand()
      |
        cmd = JsonifyCommand()
      |
        cmd = NavigateCommand()
      |
        cmd = ReconcileCommand()
      |
        cmd = ReviewCommand()
      |
        cmd = TraceCommand()
    )
    { return cmd; }
}

CommandSymbol SelectCommand() : {
    Collection<KeyTokenSymbol<?>> keys = null;
    KeyTokenSymbol<?> key = null;
    Token record = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp = null;
}
{
    <SELECT>
    (
        LOOKAHEAD(2)
        keys=KeyCollection()
      |
        key=Key() {
            keys = new ArrayList<KeyTokenSymbol<?>>();
            keys.add(key);
        }
    )
    (
        LOOKAHEAD(2)
        <FROM> record=<NUMERIC> (timestamp=TimestampReadCommand())? (Order())? (Page())?
        {
            return new SelectSymbol(keys, Long.parseLong(record.image), timestamp);
        }
      |
        LOOKAHEAD(2)
        <FROM> records=RecordCollection() (timestamp=TimestampReadCommand())? (Order())? (Page())?
        {
            return new SelectSymbol(keys, records, timestamp);
        }
      |
        <WHERE> DisjunctionExpression() (timestamp=TimestampReadCommand())? (Order())? (Page())?
        {
            return new SelectSymbol(keys, timestamp);
        }
    )
}

CommandSymbol GetCommand() : {
    KeyTokenSymbol<?> key = null;
    Collection<KeyTokenSymbol<?>> keys = null;
    Token record = null;
    Collection records = null;
    TimestampSymbol timestamp = null;
}
{
    <GET>
    (
        LOOKAHEAD(7)
        keys=KeyCollection() <WHERE> (DisjunctionExpression())? (timestamp=TimestampReadCommand())? (Order())? (Page())?
        { return new GetSymbol(keys, timestamp); }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> record=<NUMERIC> (timestamp=TimestampReadCommand())? (Order())? (Page())?
        { return new GetSymbol(key, Long.parseLong(record.image), timestamp); }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> records=RecordCollection() (timestamp=TimestampReadCommand())? (Order())? (Page())?
        { return new GetSymbol(key, records, timestamp); }
      |
        LOOKAHEAD(7)
        keys=KeyCollection() <FROM> record=<NUMERIC> (timestamp=TimestampReadCommand())? (Order())? (Page())?
        { return new GetSymbol(keys, Long.parseLong(record.image), timestamp); }
      |
        LOOKAHEAD(3)
        keys=KeyCollection() <FROM> records=RecordCollection() (timestamp=TimestampReadCommand())? (Order())? (Page())?
        { return new GetSymbol(keys, records, timestamp); }
    )
}

CommandSymbol FindCommand() : {
    TimestampSymbol timestamp = null;
}
{
    <FIND>
    DisjunctionExpression()
    (timestamp=TimestampReadCommand())?
    (Order())?
    (Page())?
    {
        return new FindSymbol(timestamp);
    }
}

CommandSymbol DescribeCommand() : {
    Token record = null;
    Collection records = null;
    TimestampSymbol timestamp = null;
}
{
    <DESCRIBE>
    (
        LOOKAHEAD(2)
        record=<NUMERIC> (timestamp=TimestampReadCommand())?
        { return new DescribeSymbol(Long.parseLong(record.image), timestamp); }
      |
        records=RecordCollection() (timestamp=TimestampReadCommand())?
        { return new DescribeSymbol(records, timestamp); }
      |
        { return new DescribeSymbol(-1, null); }
    )
}

CommandSymbol VerifyCommand() : {
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
    TimestampSymbol timestamp = null;
}
{
    <VERIFY> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    (timestamp=TimestampReadCommand())?
    { return new VerifySymbol(key, value, Long.parseLong(record.image), timestamp); }
}

CommandSymbol SearchCommand() : {
    KeyTokenSymbol<?> key;
    Token query;
}
{
    <SEARCH> key=Key() <FOR> query=<QUOTED_STRING>
    { return new SearchSymbol(key, query.image); }
}

CommandSymbol BrowseCommand() : {
    Collection<KeyTokenSymbol<?>> keys;
    TimestampSymbol timestamp = null;
}
{
    <BROWSE> keys=KeyCollection() (timestamp=TimestampReadCommand())?
    { return new BrowseSymbol(keys, timestamp); }
}

CommandSymbol ChronologizeCommand() : {
    KeyTokenSymbol<?> key;
    Token record;
    TimestampSymbol start = null;
    TimestampSymbol end = null;
}
{
    <CHRONOLOGIZE> key=Key() <IN> record=<NUMERIC>
    (
        (start=TimestampReadCommand())
        (end=TimestampReadCommand())?
    )?
    { return new ChronologizeSymbol(key, Long.parseLong(record.image), start, end); }
}

CommandSymbol DiffCommand() : {
    KeyTokenSymbol<?> key = null;
    Token record = null;
    TimestampSymbol start;
    TimestampSymbol end = null;
}
{
    <DIFF>
    (
        LOOKAHEAD(2)
        key=Key() <IN>
    )?
    (
        LOOKAHEAD(3)
        record=<NUMERIC> start=TimestampReadCommand() (end=TimestampReadCommand())?
        { return new DiffSymbol(key, Long.parseLong(record.image), start, end); }
      |
        key=Key()
        (
            LOOKAHEAD(3)
            start=TimestampReadCommand() end=TimestampReadCommand()
            { return new DiffSymbol(key, -1, start, end); }
          |
            start=TimestampReadCommand()
            { return new DiffSymbol(key, -1, start, null); }
        )
    )
}

CommandSymbol InventoryCommand() : {}
{
    <INVENTORY>
    { return InventorySymbol.INSTANCE; }
}

CommandSymbol JsonifyCommand() : {
    Token record = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp = null;
    boolean identifier = false;
}
{
    <JSONIFY>
    (
        LOOKAHEAD(2)
        record=<NUMERIC>
        { return new JsonifySymbol(Long.parseLong(record.image), identifier); }
      |
        records=RecordCollection()
        { return new JsonifySymbol(records, identifier); }
    )
    (<WITH> <RESERVED_IDENTIFIER> { identifier = true; })?
    (timestamp=TimestampReadCommand())?
}

CommandSymbol NavigateCommand() : {
    Collection<KeyTokenSymbol<?>> keys;
    Token record = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp = null;
}
{
    <NAVIGATE> keys=KeyCollection()
    (
        (<WHERE> DisjunctionExpression())
        { return new NavigateSymbol(keys, (String)null, timestamp); }
      |
        <FROM>
        (
            record=<NUMERIC> (timestamp=TimestampReadCommand())?
            { return new NavigateSymbol(keys, Long.parseLong(record.image), timestamp); }
          |
            records=RecordCollection() (timestamp=TimestampReadCommand())?
            { return new NavigateSymbol(keys, records, timestamp); }
        )
    )?
}

CommandSymbol ReconcileCommand() : {
    KeyTokenSymbol<?> key;
    Token record;
    Collection<ValueTokenSymbol<?>> values;
}
{
    <RECONCILE> key=Key() <IN> record=<NUMERIC> <WITH> values=ValueCollection()
    { return new ReconcileSymbol(key, Long.parseLong(record.image), values); }
}

CommandSymbol ReviewCommand() : {
    KeyTokenSymbol<?> key = null;
    Token record;
    TimestampSymbol start = null;
    TimestampSymbol end = null;
}
{
    <REVIEW>
    (
        LOOKAHEAD(2)
        key=Key() <IN>
    )?
    record=<NUMERIC>
    (
        (start=TimestampReadCommand())
        (end=TimestampReadCommand())?
    )?
    { return new ReviewSymbol(key, Long.parseLong(record.image), start, end); }
}

CommandSymbol TraceCommand() : {
    Token record = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp = null;
}
{
    <TRACE>
    (
        LOOKAHEAD(2)
        record=<NUMERIC>
        { return new TraceSymbol(Long.parseLong(record.image), timestamp); }
      |
        records=RecordCollection()
        { return new TraceSymbol(records, timestamp); }
    )
    (timestamp=TimestampReadCommand())?
}

// Transaction Operations
CommandSymbol TransactionOperations() : {
    CommandSymbol cmd;
}
{
    (
        cmd = StageCommand()
      |
        cmd = CommitCommand()
      |
        cmd = AbortCommand()
    )
    { return cmd; }
}

CommandSymbol StageCommand() : {}
{
    <STAGE>
    { return StageSymbol.INSTANCE; }
}

CommandSymbol CommitCommand() : {}
{
    <COMMIT>
    { return CommitSymbol.INSTANCE; }
}

CommandSymbol AbortCommand() : {}
{
    <ABORT>
    { return AbortSymbol.INSTANCE; }
}

CommandSymbol RevertCommand() : {
    KeyTokenSymbol<?> key = null;
    Token record = null;
    Collection<KeyTokenSymbol<?>> keys = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp;
}
{
    <REVERT>
    (
        LOOKAHEAD(3)
        key=Key() <IN> record=<NUMERIC>
        timestamp=TimestampReadCommand()
        { return new RevertSymbol(key, Long.parseLong(record.image), timestamp); }
      |
        LOOKAHEAD(3)
        key=Key() <IN> records=RecordCollection()
        timestamp=TimestampReadCommand()
        { return new RevertSymbol(key, records, timestamp); }
      |
        LOOKAHEAD(7)
        keys=KeyCollection() <IN> record=<NUMERIC>
        timestamp=TimestampReadCommand()
        { return new RevertSymbol(keys, Long.parseLong(record.image), timestamp); }
      |
        keys=KeyCollection() <IN> records=RecordCollection()
        timestamp=TimestampReadCommand()
        { return new RevertSymbol(keys, records, timestamp); }
    )
}

// Utility parsing rules
Collection<ValueTokenSymbol<?>> ValueCollection() : {
    ValueTokenSymbol<?> value;
    Collection<ValueTokenSymbol<?>> values = Lists.newArrayList();
}
{
    <OPEN_BRACKET>
        value=UnaryValue() { values.add(value); }
        (<COMMA> value=UnaryValue() { values.add(value); })*
    <CLOSE_BRACKET>
    { return values; }
}

Collection RecordCollection() :
{
    Token record;
    Collection records = new ArrayList();
}
{
    <OPEN_BRACKET>
        record=<NUMERIC> { records.add(Long.parseLong(record.image)); }
        (<COMMA> record=<NUMERIC> { records.add(Long.parseLong(record.image)); })*
    <CLOSE_BRACKET>
    { return records; }
}

Collection KeyCollection() :
{
    KeyTokenSymbol key;
    Collection keys = new ArrayList();
}
{
    <OPEN_BRACKET>
        key=Key() { keys.add(key.toString()); }
        (<COMMA> key=Key() { keys.add(key.toString()); })*
    <CLOSE_BRACKET>
    { return keys; }
}

String JsonObject() :
{
    Token content;
}
{
    content=<QUOTED_STRING>
    { return content.image; }
}
