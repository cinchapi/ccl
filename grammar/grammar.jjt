/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {
    MULTI=true;
    VISITOR=true;
    NODE_DEFAULT_VOID=true;
    STATIC=false;
    DEBUG_LOOKAHEAD=true;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.generated;

import com.cinchapi.ccl.SyntaxException;
import com.cinchapi.ccl.grammar.DirectionSymbol;
import com.cinchapi.ccl.grammar.FunctionTokenSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.ValueTokenSymbol;
import com.cinchapi.ccl.grammar.command.*;
import com.cinchapi.ccl.type.function.KeyConditionFunction;
import com.cinchapi.ccl.type.function.KeyRecordsFunction;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.type.function.ImplicitKeyRecordFunction;
import com.cinchapi.ccl.type.function.IndexFunction;
import com.cinchapi.ccl.grammar.NavigationKeySymbol;
import com.cinchapi.ccl.grammar.KeyTokenSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.OrderComponentSymbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.PageSymbol;
import com.cinchapi.ccl.grammar.OrderSymbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.ConditionTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.common.base.AnyStrings;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;

/**
 * The Grammar generated by JavaCC
 */
@SuppressWarnings({"unused", "rawtypes"})
public class Grammar {
    private Multimap<String, Object> data;
    private Function<String, Object> valueTransformFunction;
    private Function<String, Operator> operatorTransformFunction;
    private GrammarVisitor visitor;

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = null;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Grammar(java.io.InputStream stream,
                Function<String, Object> valueTransformFunction,
                Function<String, Operator> operatorTransformFunction,
                Multimap<String, Object> data,
                GrammarVisitor visitor) {
        this(stream, null);
        this.data = data;
        this.valueTransformFunction = valueTransformFunction;
        this.operatorTransformFunction = operatorTransformFunction;
        this.visitor = visitor;
    }

    public Operator transformOperator(String token) {
        return operatorTransformFunction.apply(token);
    }

    public Object transformValue(String token) {
        return valueTransformFunction.apply(token);
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN [IGNORE_CASE]:
{
  // Data modification commands
  < ADD: "add" >
| < SET: "set" >
| < REMOVE: "remove" >
| < CLEAR: "clear" >
| < VERIFY_AND_SWAP: "verifyAndSwap" | "verify_and_swap" >
| < VERIFY_OR_SET: "verifyOrSet" | "verify_or_set" >

  // Record operations
| < INSERT: "insert" >

  // Link operations
| < LINK: "link" >
| < UNLINK: "unlink" >

  // Query operations
| < SELECT: "select" >
| < FETCH: "fetch" >
| < GET: "get" >
| < DESCRIBE: "describe" >
| < AUDIT: "audit" >
| < VERIFY: "verify" >
| < SEARCH: "search" >

  // Transaction operations
| < STAGE: "stage" >
| < COMMIT: "commit" >
| < ABORT: "abort" >

  // Other tokens needed for command syntax
| < REVERT: "revert" >
| < IN: "in" >
| < INTO: "into" >
| < FROM: "from" >
| < TO: "to" >
| < AS: "as" >
| < FOR: "for" >
| < WITH: "with" >
| < OPEN_BRACE : "{" >
| < CLOSE_BRACE : "}" >
| < COLON : ":" >
}


TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN : { < OPEN_BRACKET : "[" > }
TOKEN : { < CLOSE_BRACKET : "]" > }
TOKEN [IGNORE_CASE]: {< TIMESTAMP: "at" | "on" | "during" | "as of" > }
TOKEN [IGNORE_CASE]: { < WHERE: "where" > }
TOKEN [IGNORE_CASE]: { < RESERVED_IDENTIFIER: "$id$" > }

TOKEN [IGNORE_CASE]:
{
  < CONJUNCTION: "and" | "&&" | "&" >
|
  < DISJUNCTION: "or" | "||" >
}

TOKEN [IGNORE_CASE]:
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < OPEN_ANGLE_BRACKET : "<" >
|
  < CLOSE_ANGLE_BRACKET : ">" >
|
  < #EQUALS: "=" | "==" | "eq" | "equals" >
|
  < #NOT_EQUALS: "!=" | "ne" | "not_equals" >
|
  < #GREATER_THAN: "gt" | "greater_than">
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" | "greater_than_or_equals" >
|
  < #LESS_THAN: "lt" | "less_than">
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" | "less_than_or_equals" >
|
  < LINKS_TO: "->" | "lnks2" | "lnk2" | "links_to" >
|
  < REGEX: "regex" >
|
  < NOT_REGEX: "nregex" | "not_regex" >
|
  < LIKE: "like" >
|
  < NOT_LIKE: "nlike" | "not_like" >
|
  < #BETWEEN: "><" | "bw" | "between" >
|
  < PAGE : "page" >
|
  < SIZE : "size" >
|
  < ORDER : "order by" >
|
  < ASC : "asc" >
|
  < DESC : "desc" >
}

TOKEN :
{
  < PIPE : "|" >
|
  < QUOTED_STRING : <DOUBLE_QUOTED_STRING> | <SINGLE_QUOTED_STRING> >
|
  < DOUBLE_QUOTED_STRING : ("\"" ("\\" ~[] | ~["\"", "\\"])+ "\"") | ("“" ("\\" ~[] | ~["”", "\\"])+ "”") >
|
  < SINGLE_QUOTED_STRING : ("'" ("\\" ~[] | ~["'", "\\"])+ "'") | ("‘" ("\\" ~[] | ~["’", "\\"])+ "’") | ("`" ("\\" ~[] | ~["`", "\\"])+ "`") >
|
  < NUMERIC: (<DIGIT>)+ >
|
  < COMMA : "," >
|
  < SIGNED_INTEGER : (("-" | "+")? (<DIGIT>)+) >
|
  < SIGNED_DECIMAL : (("-" | "+")?  (<DIGIT>)+<PERIOD>(<DIGIT>)+ ) >
|
  < ALPHANUMERIC: (<LETTER>|<DIGIT>)+ >
|
  < PERIOD_SEPARATED_STRING: (<SIGNED_DECIMAL> | <ALPHANUMERIC>) ("." (<SIGNED_DECIMAL> | <ALPHANUMERIC>))* >
|
  < NON_ALPHANUMERIC_AND_ALPHANUMERIC: (<NON_ALPHANUMERIC>|<ALPHANUMERIC>)+ >
|
  < #NON_ALPHANUMERIC: ~[",", "_","a"-"z","A"-"Z", "\n", "\t", "\r", " ", "(", ")", "[", "]", "="] >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #PERIOD: "." >
}

ASTStart StartCommandLine() #Start : {}
{
   ( LOOKAHEAD(4)
     Command() "\n"
   |
     LOOKAHEAD(3)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? "\n"
   |
     Page() "\n"
   |
     Order() "\n"
   |
     Function() "\n"
   )
   { return jjtThis; }
}

ASTStart generateAST() #Start : {}
{
   ( LOOKAHEAD(4)
     Command() <EOF>
   |
     LOOKAHEAD(3)
     (<WHERE>)? DisjunctionExpression() (Order())? (Page())? <EOF>
   |
     Page() <EOF>
   |
     Order() <EOF>
   |
     Function() <EOF>
   )
   { return jjtThis; }
}

ASTStart generateSubAST() #Start : {}
{
   DisjunctionExpression()
   { return jjtThis; }
}

void DisjunctionExpression() : {}
{
  (
    ConjunctionExpression() (((<DISJUNCTION>) ConjunctionExpression()) #Or(2) )*
  )
}

void ConjunctionExpression() : {}
{
  (
    UnaryExpression() (((<CONJUNCTION>) UnaryExpression()) #And(2) )*
  )
}

void UnaryExpression() : {}
{
   (<OPEN_PARENTHESES>) DisjunctionExpression() (<CLOSE_PARENTHESES>) | RelationalExpression()
}

void RelationalExpression() #Expression :
{
    KeyTokenSymbol key = null;
    OperatorSymbol operator = null;
    ValueTokenSymbol value1 = null;
    ValueTokenSymbol value2 = null;
    TimestampSymbol timestamp = null;
}
{
    key=Key()
      (
        operator=LinksToOperator() value1=LinksToValue() (timestamp=Timestamp())?
      |
        operator=RegexBasedOperator() value1=RegexValue() (timestamp=Timestamp())?
      |
        operator=UnaryOperator() value1=UnaryValue() (timestamp=Timestamp())?
      |
        operator=BinaryOperator() value1=BinaryValue() value2=BinaryValue() (timestamp=Timestamp())?
      ) { jjtThis.key(key);
          jjtThis.operator(operator);
          jjtThis.addValue(value1);
          if(value2 != null) jjtThis.addValue(value2);
          if(timestamp != null) jjtThis.timestamp(timestamp);
        }
}

KeyTokenSymbol Key() :
{
  FunctionKeySymbol function;
  Token key;
}
{
  (
    LOOKAHEAD(2)

    (function=KeyFunction())
    { return function; }
  |
    (key=<RESERVED_IDENTIFIER> | key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC>)
    { return new KeySymbol(key.image); }
  |
    (key=<PERIOD_SEPARATED_STRING>)
    { return new NavigationKeySymbol(key.image); }
  )
}

ValueTokenSymbol UnaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  ( LOOKAHEAD(2) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>) { value += (value.equals("")) ? word.image : " " + word.image; })+
  {
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol LinksToValue() :
{
  Token word;
}
{
  (word=<NUMERIC>)
  { return new ValueSymbol(transformValue(word.image)); }
}

ValueTokenSymbol RegexValue() :
{
  Token word;
  String value = "";

}
{
    <OPEN_PARENTHESES> (LOOKAHEAD(4) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>  | word="_" | word="=")
    {
        if (value.equals("") |
            value.endsWith("(") | word.image.equals(")") |
            value.endsWith("=") | word.image.equals("=") |
            value.endsWith("_") | word.image.equals("_")) {
            value += word.image;
        }
        else {
            value += " " + word.image;
        }
    })+ <CLOSE_PARENTHESES>
    { return new ValueSymbol(transformValue("(" + value + ")")); }
  |
    (LOOKAHEAD(3) (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>  | word="_" | word="=")
    {
        if (value.equals("") |
            value.endsWith("(") | word.image.equals(")") |
            value.endsWith("=") | word.image.equals("=") |
            value.endsWith("_") | word.image.equals("_")) {
            value += word.image;
        }
        else {
            value += " " + word.image;
        }
    })+
    { return new ValueSymbol(transformValue(value)); }
  |
    (word=<QUOTED_STRING>)
    { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

ValueTokenSymbol BinaryValue() :
{
  FunctionValueSymbol function;
  Token key;
  Token word;
  String value = "";
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
}
{
  LOOKAHEAD(2)

  (function=ValueFunction())
  { return function; }
|
  (word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>  | word=<PERIOD_SEPARATED_STRING>)
  {
    value = word.image;
    if(value.charAt(0) == '$') {
        String var = value.substring(1);
        try {
            value = Iterables.getOnlyElement(data.get(var)).toString();
        }
        catch (IllegalArgumentException e) {
            String err = "Unable to resolve variable {} because multiple values exist locally: {}";
            throw new SyntaxException(AnyStrings.format(err, value, data.get(var)));
        }
        catch (NoSuchElementException e) {
            String err = "Unable to resolve variable {} because no values exist locally";
            throw new SyntaxException(AnyStrings.format(err, value));
        }
    }
    else if(value.length() > 2 && value.charAt(0) == '\\'
            && value.charAt(1) == '$') {
        value = value.substring(1);
    }
    else {
        value = value.replace("\\@", "@");
    }
    return new ValueSymbol(transformValue(value));
  }
|
  (word=<QUOTED_STRING>)
  { return new ValueSymbol(transformValue(word.image.replace("\\\"", "\""))); }
}

OperatorSymbol LinksToOperator() :
{
  Token operator;
}
{
  operator=<LINKS_TO> { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol RegexBasedOperator() :
{
  Token operator;
}
{
  (operator=<REGEX> | operator=<NOT_REGEX> | operator=<LIKE> | operator =<NOT_LIKE>) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol UnaryOperator() :
{
  Token operator;
}
{
  (operator=<UNARY_OPERATOR> | operator=<OPEN_ANGLE_BRACKET> | operator=<CLOSE_ANGLE_BRACKET> ) { return new OperatorSymbol(transformOperator(operator.image)); }
}

OperatorSymbol BinaryOperator() :
{
  Token operator;
}
{
  operator=<BINARY_OPERATOR> { return new OperatorSymbol(transformOperator(operator.image)); }
}

TimestampSymbol Timestamp() :
{
  Token word;
  String timestamp = "";
}
{
  (<TIMESTAMP> | <IN>) (LOOKAHEAD(2) (word=<QUOTED_STRING> | word=<SIGNED_INTEGER> | word=<SIGNED_DECIMAL> | word=<NUMERIC> | word=<ALPHANUMERIC> | word=<NON_ALPHANUMERIC_AND_ALPHANUMERIC>) { timestamp += (timestamp.equals("")) ? word.image : " " + word.image; })+
  { return new TimestampSymbol(NaturalLanguage.parseMicros(timestamp)); }
}

void Page() #Page :
{
  String number = null;
  String size = null;
}
{
  (
    number=Number() (size=Size())?
  |
    size=Size() (number=Number())?
  )
  { jjtThis.page(new PageSymbol(number != null ? Integer.parseInt(number) : null, size != null ? Integer.parseInt(size) : null)); }
}

String Number() :
{
   Token number;
}
{
  (
     (<PAGE> number=<NUMERIC>)
     { return number.image; }
  )
}

String Size() :
{
   Token size;
}
{
  (
     (<SIZE> size=<NUMERIC>)
     { return size.image; }
  )
}

void Order() #Order :
{
    OrderSymbol order = new OrderSymbol();
    OrderComponentSymbol orderComponent;
}
{
  (<ORDER>
  (orderComponent=OrderClause()
      { order.add(orderComponent); }
    (<COMMA> orderComponent=OrderClause()
      { order.add(orderComponent); })*))
  { jjtThis.order(order); }
}

OrderComponentSymbol OrderClause() :
{
    KeyTokenSymbol key;
    TimestampSymbol timestamp = null;
    DirectionSymbol direction = null;
}
{

  ((
    direction=SymbolicDirection() key=Key()
  |
    key=Key() (direction=WordDirection())?
  )
  (timestamp=Timestamp())?)
  {
      if(direction != null) {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp, direction);
          }
          else {
              return new OrderComponentSymbol(key, direction);
          }
      }
      else {
          if(timestamp != null) {
              return new OrderComponentSymbol(key, timestamp,
                  DirectionSymbol.ASCENDING);
          }
          else {
              return new OrderComponentSymbol(key,
                  DirectionSymbol.ASCENDING);
          }
      }
  }
}

DirectionSymbol SymbolicDirection() :
{
   Token direction;
}
{
  (
      direction=<OPEN_ANGLE_BRACKET>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<CLOSE_ANGLE_BRACKET>
      { return DirectionSymbol.DESCENDING; }
  )
}

DirectionSymbol WordDirection() :
{
   Token direction;
}
{
  (
      direction=<ASC>
      { return DirectionSymbol.ASCENDING; }
    |
      direction=<DESC>
      { return DirectionSymbol.DESCENDING; }
  )
}

void Function() #Function :
{
    FunctionTokenSymbol function;
}
{
  ( LOOKAHEAD(2)
    function = KeyFunction()
  |
    function = ValueFunction()
  )
  { jjtThis.function(function);}
}

FunctionKeySymbol KeyFunction() :
{
  Token key;
  Token function;
}
{
   (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<NUMERIC> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <PIPE> function=<ALPHANUMERIC>
   { return new FunctionKeySymbol(new ImplicitKeyRecordFunction(function.image, key.image.substring(0, key.image.length())));}
}

FunctionValueSymbol ValueFunction() :
{
  Token function;
  Token key;
  Token word;
  List<String> records = Lists.newArrayList();
  ASTStart ccl;
  TimestampSymbol timestamp = null;
}
{
  function=<ALPHANUMERIC> <OPEN_PARENTHESES>
   (
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>)
     (
         <CLOSE_PARENTHESES>
         { return new FunctionValueSymbol(new IndexFunction(function.image, key.image));}
     |
         <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
         { return new FunctionValueSymbol(new IndexFunction(function.image, key.image, timestamp.timestamp()));}
     )
   |
     LOOKAHEAD(3)

     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <COMMA>
     (
        (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image);}
        (<COMMA> (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image); })* <CLOSE_PARENTHESES>
        { return new FunctionValueSymbol(new KeyRecordsFunction(function.image, key.image, records));}
     |
        <OPEN_BRACKET>
        (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image);}
        (<COMMA> (word=<SIGNED_INTEGER> | word=<NUMERIC>){ records.add(word.image); })*
        <CLOSE_BRACKET> <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
        { return new FunctionValueSymbol(new KeyRecordsFunction(function.image, key.image, records, timestamp.timestamp()));}
     )
   |
     (key=<SIGNED_INTEGER> | key=<SIGNED_DECIMAL> | key=<ALPHANUMERIC> | key=<PERIOD_SEPARATED_STRING>) <COMMA> ccl=generateSubAST()
     (
        <CLOSE_PARENTHESES>
        {
          ConditionTree tree = (ConditionTree) ccl.jjtAccept(visitor, null);
          return new FunctionValueSymbol(new KeyConditionFunction(function.image, key.image, tree));
        }
     |
        <COMMA> timestamp=Timestamp() <CLOSE_PARENTHESES>
        {
          ConditionTree tree = (ConditionTree) ccl.jjtAccept(visitor, null);
          return new FunctionValueSymbol(new KeyConditionFunction(function.image, key.image, tree, timestamp.timestamp()));
        }
     )
   )
}

void Command() : {}
{
      DataModificationOperations()
    |
      RecordOperations()
    |
      LinkOperations()
    |
      QueryOperations()
    |
      TransactionOperations()
    |
      RevertCommand()
}

void DataModificationOperations() : {}
{
    AddCommand()
  |
    SetCommand()
  |
    RemoveCommand()
  |
    ClearCommand()
  |
    VerifyAndSwapCommand()
  |
    VerifyOrSetCommand()
}

void AddCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
}
{
    <ADD> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    {
        jjtThis.command(new AddSymbol(key, value, Long.parseLong(record.image)));
    }
}

void SetCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
}
{
    <SET> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    {
        jjtThis.command(new SetSymbol(key, value, Long.parseLong(record.image)));
    }
}

void RemoveCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value = null;
    Token record;
}
{
    <REMOVE> key=Key() (<AS> value=UnaryValue())? (<FROM> | <IN>) record=<NUMERIC>
    {
        jjtThis.command(new RemoveSymbol(key, value, Long.parseLong(record.image)));
    }
}

void ClearCommand() #Command :
{
    KeyTokenSymbol<?> key = null;
    Token record;
    Collection<KeyTokenSymbol<?>> keys = null;
    Collection records = null;
}
{
    <CLEAR>
    (
        LOOKAHEAD(3)
        key=Key() <FROM> record=<NUMERIC>
        {
            jjtThis.command(new ClearSymbol(key, Long.parseLong(record.image)));
        }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> records=RecordCollection()
        {
            jjtThis.command(new ClearSymbol(key, records));
        }
      |
        LOOKAHEAD(3)
        keys=KeyCollection() <FROM> record=<NUMERIC>
        {
            jjtThis.command(new ClearSymbol(keys, Long.parseLong(record.image)));
        }
      |
        keys=KeyCollection() <FROM> records=RecordCollection()
        {
            jjtThis.command(new ClearSymbol(keys, records));
        }
    )
}

void VerifyAndSwapCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> expected;
    ValueTokenSymbol<?> replacement;
    Token record;
}
{
    <VERIFY_AND_SWAP> key=Key() <AS> expected=UnaryValue() <IN> record=<NUMERIC>
    <WITH> replacement=UnaryValue()
    {
        jjtThis.command(new VerifyAndSwapSymbol(key, expected, replacement, Long.parseLong(record.image)));
    }
}

void VerifyOrSetCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
}
{
    <VERIFY_OR_SET> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    {
        jjtThis.command(new VerifyOrSetSymbol(key, value, Long.parseLong(record.image)));
    }
}

void RecordOperations() : {}
{
    InsertCommand()
}

void InsertCommand() #Command :
{
    String json;
    Token record = null;
    Collection records = null;
}
{
    <INSERT> json=JsonObject()
    (
        (<IN> | <INTO>)
        (
            record=<NUMERIC>
            {
                jjtThis.command(new InsertSymbol(json, Long.parseLong(record.image)));
            }
          |
            records=RecordCollection()
            {
                jjtThis.command(new InsertSymbol(json, records));
            }
        )
    )?
    {
        if(record == null && records == null) {
            jjtThis.command(new InsertSymbol(json));
        }
    }
}

void LinkOperations() : {}
{
    LinkCommand()
  |
    UnlinkCommand()
}

void LinkCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Token source;
    Token destination;
    Collection destinations = null;
}
{
    <LINK> key=Key() <FROM> source=<NUMERIC> <TO>
    (
        destination=<NUMERIC>
        {
            Collection dest = new ArrayList();
            dest.add(Long.parseLong(destination.image));
            jjtThis.command(new LinkSymbol(key, Long.parseLong(source.image), dest));
        }
      |
        destinations=RecordCollection()
        {
            jjtThis.command(new LinkSymbol(key, Long.parseLong(source.image), destinations));
        }
    )
}

void UnlinkCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Token source;
    Token destination;
    Collection destinations = null;
}
{
    <UNLINK> key=Key() <FROM> source=<NUMERIC> <TO>
    (
        destination=<NUMERIC>
        {
            Collection dest = new ArrayList();
            dest.add(Long.parseLong(destination.image));
            jjtThis.command(new UnlinkSymbol(key, Long.parseLong(source.image), dest));
        }
      |
        destinations=RecordCollection()
        {
            jjtThis.command(new UnlinkSymbol(key, Long.parseLong(source.image), destinations));
        }
    )
}

void QueryOperations() : {}
{
    SelectCommand()
  |
    FetchCommand()
  |
    GetCommand()
  |
    DescribeCommand()
  |
    AuditCommand()
  |
    VerifyCommand()
  |
    SearchCommand()
}

void SelectCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Token record;
    TimestampSymbol timestamp = null;
}
{
    <SELECT> key=Key() <FROM> record=<NUMERIC> (timestamp=Timestamp())?
    {
        jjtThis.command(new SelectSymbol(key, Long.parseLong(record.image), timestamp));
    }
}

void FetchCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Collection<KeyTokenSymbol<?>> keys = null;
    Token record;
    Collection records = null;
    TimestampSymbol timestamp = null;
}
{
    <FETCH>
    (
        LOOKAHEAD(3)
        key=Key() <FROM> record=<NUMERIC> (timestamp=Timestamp())?
        {
            jjtThis.command(new FetchSymbol(key, Long.parseLong(record.image), timestamp));
        }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> records=RecordCollection() (timestamp=Timestamp())?
        {
            jjtThis.command(new FetchSymbol(key, records, timestamp));
        }
      |
        LOOKAHEAD(3)
        keys=KeyCollection() <FROM> record=<NUMERIC> (timestamp=Timestamp())?
        {
            jjtThis.command(new FetchSymbol(keys, Long.parseLong(record.image), timestamp));
        }
      |
        keys=KeyCollection() <FROM> records=RecordCollection() (timestamp=Timestamp())?
        {
            jjtThis.command(new FetchSymbol(keys, records, timestamp));
        }
    )
}

void GetCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Collection<KeyTokenSymbol<?>> keys = null;
    Token record;
    Collection records = null;
    TimestampSymbol timestamp = null;
}
{
    <GET>
    (
        LOOKAHEAD(3)
        key=Key() <FROM> record=<NUMERIC> (timestamp=Timestamp())?
        {
            jjtThis.command(new GetSymbol(key, Long.parseLong(record.image), timestamp));
        }
      |
        LOOKAHEAD(3)
        key=Key() <FROM> records=RecordCollection() (timestamp=Timestamp())?
        {
            jjtThis.command(new GetSymbol(key, records, timestamp));
        }
      |
        LOOKAHEAD(3)
        keys=KeyCollection() <FROM> record=<NUMERIC> (timestamp=Timestamp())?
        {
            jjtThis.command(new GetSymbol(keys, Long.parseLong(record.image), timestamp));
        }
      |
        keys=KeyCollection() <FROM> records=RecordCollection() (timestamp=Timestamp())?
        {
            jjtThis.command(new GetSymbol(keys, records, timestamp));
        }
    )
}

void DescribeCommand() #Command :
{
    Token record;
    Collection records = null;
    TimestampSymbol timestamp = null;
}
{
    <DESCRIBE>
    (
        LOOKAHEAD(2)
        record=<NUMERIC> (timestamp=Timestamp())?
        {
            jjtThis.command(new DescribeSymbol(Long.parseLong(record.image), timestamp));
        }
      |
        records=RecordCollection() (timestamp=Timestamp())?
        {
            jjtThis.command(new DescribeSymbol(records, timestamp));
        }
    )
}

void AuditCommand() #Command :
{
    KeyTokenSymbol<?> key = null;
    Token record;
}
{
    <AUDIT>
    (
        LOOKAHEAD(2)
        key=Key() <FROM> record=<NUMERIC>
        {
            jjtThis.command(new AuditSymbol(key, Long.parseLong(record.image)));
        }
      |
        record=<NUMERIC>
        {
            jjtThis.command(new AuditSymbol(null, Long.parseLong(record.image)));
        }
    )
}

void VerifyCommand() #Command :
{
    KeyTokenSymbol<?> key;
    ValueTokenSymbol<?> value;
    Token record;
    TimestampSymbol timestamp = null;
}
{
    <VERIFY> key=Key() <AS> value=UnaryValue() <IN> record=<NUMERIC>
    (timestamp=Timestamp())?
    {
        jjtThis.command(new VerifySymbol(key, value, Long.parseLong(record.image), timestamp));
    }
}

void SearchCommand() #Command :
{
    KeyTokenSymbol<?> key;
    Token query;
}
{
    <SEARCH> key=Key() <FOR> query=<QUOTED_STRING>
    {
        jjtThis.command(new SearchSymbol(key, query.image));
    }
}

void TransactionOperations() : {}
{
    StageCommand()
  |
    CommitCommand()
  |
    AbortCommand()
}

void StageCommand() #Command : {}
{
    <STAGE>
    {
        jjtThis.command(StageSymbol.INSTANCE);
    }
}

void CommitCommand() #Command : {}
{
    <COMMIT>
    {
        jjtThis.command(CommitSymbol.INSTANCE);
    }
}

void AbortCommand() #Command : {}
{
    <ABORT>
    {
        jjtThis.command(AbortSymbol.INSTANCE);
    }
}

void RevertCommand() #Command : {
    KeyTokenSymbol<?> key = null;
    Token record = null;
    Collection<KeyTokenSymbol<?>> keys = null;
    Collection<Long> records = null;
    TimestampSymbol timestamp;
}
{
    <REVERT>
    (
        LOOKAHEAD(3)
        key=Key() <IN> record=<NUMERIC>
        timestamp=Timestamp()
        {
            jjtThis.command(new RevertSymbol(key, Long.parseLong(record.image), timestamp));
        }
      |
        LOOKAHEAD(3)
        key=Key() <IN> records=RecordCollection()
        timestamp=Timestamp()
        {
            jjtThis.command(new RevertSymbol(key, records, timestamp));
        }
      |
        LOOKAHEAD(3)
        keys=KeyCollection() <IN> record=<NUMERIC>
        timestamp=Timestamp()
        {
            jjtThis.command(new RevertSymbol(keys, Long.parseLong(record.image), timestamp));
        }
      |
        keys=KeyCollection() <IN> records=RecordCollection()
        timestamp=Timestamp()
        {
            jjtThis.command(new RevertSymbol(keys, records, timestamp));
        }
    )
}

// Utility parsing rules
Collection RecordCollection() :
{
    Token record;
    Collection records = new ArrayList();
}
{
    <OPEN_BRACKET>
        record=<NUMERIC> { records.add(Long.parseLong(record.image)); }
        (<COMMA> record=<NUMERIC> { records.add(Long.parseLong(record.image)); })*
    <CLOSE_BRACKET>
    { return records; }
}

Collection KeyCollection() :
{
    KeyTokenSymbol key;
    Collection keys = new ArrayList();
}
{
    <OPEN_BRACKET>
        key=Key() { keys.add(key.toString()); }
        (<COMMA> key=Key() { keys.add(key.toString()); })*
    <CLOSE_BRACKET>
    { return keys; }
}

String JsonObject() :
{
    Token content;
}
{
    content=<QUOTED_STRING>
    { return content.image; }
}
