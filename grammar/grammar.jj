/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. grammar.jj */
/*@egen*//*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

options {



    STATIC=false;
}

PARSER_BEGIN(Grammar)

package com.cinchapi.ccl.v2.generated;

/**
 * The Grammar generated by JavaCC
 */
public class Grammar/*@bgen(jjtree)*/implements GrammarTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTGrammarState jjtree = new JJTGrammarState();

/*@egen*/
    public static void main(String args[]) {
        System.out.println("Reading from standard input...");
        Grammar grammar = new Grammar(System.in);
        while (true) {
            try {
                ASTStart start = grammar.StartCommandLine();
                GrammarVisitor visitor = new GrammarDumpVisitor();
                start.jjtAccept(visitor, null);
                System.out.println("Thank you.");
            } catch (Exception e) {
                System.out.println("Oops.");
                System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }
    }
}

PARSER_END(Grammar)


SKIP :
{
  " "
|
  "\t"
}

TOKEN : { < OPEN_PARENTHESES : "(" > }
TOKEN : { < CLOSE_PARENTHESES : ")" > }
TOKEN : { < TIMESTAMP: "at" | "on" | "during" | "in" > }

TOKEN : /* CONJUNCTIONS */
{
  < CONJ: <CONJUNCTION> | <DISJUNCTION> >
|
  < #CONJUNCTION: "and" | "&&" | "&" >
|
  < #DISJUNCTION: "or" | "||" | "|" >
}

TOKEN :
{
  < UNARY_OPERATOR: <EQUALS> | <NOT_EQUALS> | <LESS_THAN> | <LESS_THAN_OR_EQUALS> | <GREATER_THAN> | <GREATER_THAN_OR_EQUALS> | <REGEX> | <NOT_REGEX> >
|
  < BINARY_OPERATOR: <BETWEEN> >
|
  < #EQUALS: "=" | "==" | "eq" >
|
  < #NOT_EQUALS: "!=" | "ne" >
|
  < #GREATER_THAN: ">" | "gt" >
|
  < #GREATER_THAN_OR_EQUALS: ">=" | "gte" >
|
  < #LESS_THAN: "<" | "lt" >
|
  < #LESS_THAN_OR_EQUALS: "<=" | "lte" >
|
  < #LINKS_TO: "->" | "lnks2" | "lnk2" >
|
  < #REGEX: "regex" >
|
  < #NOT_REGEX: "nregex" >
|
  < #LIKE: "like" >
|
  < #NOT_LIKE: "nlike" >
|
  < #BETWEEN: "><" | "bw" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: (<SYMBOL>)(<LETTER>|<DIGIT>)+ | (<LETTER>|<DIGIT>)+ >
|
  < #SYMBOL: "$" >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}


/** Main production. */
ASTStart Start()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  Expression() <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** Main production. */
ASTStart StartCommandLine()        : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  Expression() "\n"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/** An Expression. */
void Expression() :
{
  Token o;
}
{
  (
    UnaryExpression() (/*@bgen(jjtree) #Conj( 2) */
                       {
                         ASTConj jjtn001 = new ASTConj(JJTCONJ);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
                       }
                       try {
/*@egen*/(o=<CONJ> { jjtn001.symbol(o.image); } UnaryExpression())/*@bgen(jjtree)*/
                       } catch (Throwable jjte001) {
                         if (jjtc001) {
                           jjtree.clearNodeScope(jjtn001);
                           jjtc001 = false;
                         } else {
                           jjtree.popNode();
                         }
                         if (jjte001 instanceof RuntimeException) {
                           throw (RuntimeException)jjte001;
                         }
                         if (jjte001 instanceof ParseException) {
                           throw (ParseException)jjte001;
                         }
                         throw (Error)jjte001;
                       } finally {
                         if (jjtc001) {
                           jjtree.closeNodeScope(jjtn001,  2);
                         }
                       }
/*@egen*/         )*
  )
}

void UnaryExpression() : {}
{
   <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES> | RelationalExpression()
}

void RelationalExpression()                       :
{/*@bgen(jjtree) RelationalExpression */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token k;
  Token o;
  Token v;
  Token t;
}
{/*@bgen(jjtree) RelationalExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)

  k=<IDENTIFIER> { jjtn000.key(k.image);}
  o=<UNARY_OPERATOR> { jjtn000.operator(o.image);}
  (v=<IDENTIFIER> { jjtn000.appendValue(v.image); } )+
  (<TIMESTAMP> (t=<IDENTIFIER> { jjtn000.timestamp(t.image);})+ )?
|
  k=<IDENTIFIER> { jjtn000.key(k.image);}
  o=<BINARY_OPERATOR> { jjtn000.operator(o.image);}
  v=<IDENTIFIER> { jjtn000.addValue(v.image); }
  v=<IDENTIFIER> { jjtn000.addValue(v.image); }
  (<TIMESTAMP> (t=<IDENTIFIER> { jjtn000.timestamp(t.image);})+ )?/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
