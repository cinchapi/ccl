/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import com.cinchapi.ccl.generated.ASTFunction;
import com.cinchapi.ccl.generated.ASTOrder;
import com.cinchapi.ccl.generated.ASTPage;
import com.cinchapi.ccl.generated.Grammar;
import com.cinchapi.ccl.generated.GrammarVisitor;
import com.cinchapi.ccl.syntax.AndTree;
import com.cinchapi.ccl.syntax.ConditionTree;
import com.cinchapi.ccl.syntax.ExpressionTree;
import com.cinchapi.ccl.syntax.FunctionTree;
import com.cinchapi.ccl.syntax.OrTree;
import com.cinchapi.ccl.syntax.OrderTree;
import com.cinchapi.ccl.syntax.PageTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.generated.ASTAnd;
import com.cinchapi.ccl.generated.ASTExpression;
import com.cinchapi.ccl.generated.ASTOr;
import com.cinchapi.ccl.generated.ASTStart;
import com.cinchapi.ccl.generated.SimpleNode;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import org.junit.Test;

import com.cinchapi.ccl.generated.ParseException;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.function.Function;

/**
 * Tests for {@link Grammar}
 */
public class GrammarTest {

    @Test
    public void validUnaryOperatorSingleWordValueExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validUnaryOperatorMultiWordValueExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 2";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validBinaryOperatorExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a >< 1 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validImplicitContextFunctionAsEvaluationKey() throws UnsupportedEncodingException, ParseException {
        String ccl = "friends | avg > 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validImplicitIndexFunctionAsEvaluationValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "age > avg(age)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validExplicitFunctionWithSingleRecordAsEvaluationValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "age > avg(age, 1)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validExplicitFunctionWithBetween() throws UnsupportedEncodingException, ParseException {
        String ccl = "age bw avg(age) 1000";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validExplicitFunctionWithBetweenCCL() throws UnsupportedEncodingException, ParseException {
        String ccl = "age bw avg(age, age > 10) 1000";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validExplicitFunctionWithMultipleRecordsAsEvaluationValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "age > avg(age, 1, 2)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validExplicitFunctionWithCCLAsEvaluationValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "age > avg(age, age < 30)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validImplicitRecordFunctionAsEvaluationKeyAndExplicitFunctionWithCCLAsEvaluationValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "age | avg > avg(age, age < 30)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingSecondOperandBinaryOperator() throws UnsupportedEncodingException, ParseException {
        String ccl = "a >< 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void tooManyOperandsBinaryOperator() throws UnsupportedEncodingException, ParseException {
        String ccl = "a >< 1 2 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSingleWordTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 at today";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validJsonReservedIdentifier() throws UnsupportedEncodingException, ParseException {
        String ccl = "$id$ != 40";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validMultiwordTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 on last christmas";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 at";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validQuotedValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = \"name\"";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void singleLeftAndRightQuotation() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = ‘name’";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validQuotedValueWithQuote() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = \"wood\\\"ford\"";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validLocalResolution() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, data, visitor);
        grammar.generateAST();
    }

    @Test
    public void validEscapedLocalResolution() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = \\$name";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validImplicitLink() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = @name";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validImplicitEscapedLink() throws UnsupportedEncodingException, ParseException {
        String ccl = "name = \\@name";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validLink() throws UnsupportedEncodingException, ParseException {
        String ccl = "a -> 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validConjunctionExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 and b = 2";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validDisjunctionExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 or b = 2";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validParenthesizedExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 or (b = 2 and c = 3)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void operatorEnum() throws UnsupportedEncodingException, ParseException {
        String ccl = "a LINKS_TO 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validNavigationKeyAsEvaluationKey() throws UnsupportedEncodingException, ParseException {
        String ccl = "a.b = 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validLongNavigationKeyAsEvaluationKey() throws UnsupportedEncodingException, ParseException {
        String ccl = "a.b.c.d = 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validPeriodSeparatedValue() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = a.b.c";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validRegex() throws UnsupportedEncodingException, ParseException {
        String ccl = "name nregex (?i:%jeff%)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validLikeWithSecondParenthesizedExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "(a = b) and (name like (?i:%jeff%))";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validLike() throws UnsupportedEncodingException, ParseException {
        String ccl = "name like (?i:%jeff%)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchMatchWord() throws UnsupportedEncodingException, ParseException {
        String ccl = "major search_match 'business administration'";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchMatchContains() throws UnsupportedEncodingException, ParseException {
        String ccl = "major contains 'business administration'";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchMatchOp() throws UnsupportedEncodingException, ParseException {
        String ccl = "major ~ 'business administration'";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchExcludeWord() throws UnsupportedEncodingException, ParseException {
        String ccl = "name search_exclude jeff at last week";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchExcludeNotContains() throws UnsupportedEncodingException, ParseException {
        String ccl = "major not_contains 'business administration'";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validSearchExcludeOP() throws UnsupportedEncodingException, ParseException {
        String ccl = "name !~ jeff at last week";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingKeyExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "= 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingValueExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a =";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingOperatorExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingSecondExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 and";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void missingFirstExpression() throws UnsupportedEncodingException, ParseException {
        String ccl = "and a = 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test (expected = ParseException.class)
    public void invalidLink() throws UnsupportedEncodingException, ParseException {
        String ccl = "a LINKS_TO b";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testWithNumber() throws UnsupportedEncodingException, ParseException {
        String input = PAGE + " 3";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testWithNumberAndSize() throws UnsupportedEncodingException, ParseException {
        String input = SIZE + " 1 " + PAGE + " 3";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testWithSize() throws UnsupportedEncodingException, ParseException {
        String input = SIZE + " 3";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testWithSizeAndNumber() throws UnsupportedEncodingException, ParseException {
        String input = SIZE + " 1 " + PAGE + " 3";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validUnaryOperatorWithPage() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 page 1 size 3";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKey() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyAscendingSymbol() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " < age";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyAscendingWord() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age ASC";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyDescendingSymbol() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " > age";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyDescendingWord() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age DESC";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithNumberTimestamp() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age at " + String.valueOf(122L);

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithStringTimestamp() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age at \"1992-10-02\"";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithNumberTimestampAscending() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + "  > age at " + String.valueOf(122L);

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithStringTimestampAscending() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " < age at \"1992-10-02\"";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithNumberTimestampDescending() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " > age at " + String.valueOf(122L);

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyWithStringTimestampDescending() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " > age at \"1992-10-02\"";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testMultipleKeys() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " age, salary";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testMultipleKeysWithDirectional() throws UnsupportedEncodingException, ParseException {
        String input = ORDER + " < age, > salary";

        InputStream stream = new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validUnaryOperatorWithOrder() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 " + ORDER + " a";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void validUnaryOperatorWithOrderAndPage() throws UnsupportedEncodingException, ParseException {
        String ccl = "a = 1 " + ORDER + " a " + SIZE+ " 3 " + PAGE + " 1";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyMultiRecordsFunction() throws UnsupportedEncodingException, ParseException {
        String ccl = "avg(age, 1,2,3,5,11)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyMultiRecordsFunctionWithTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "avg(age, [1,2,3,5,11], at today)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testKeyConditionFunctionWithTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "avg(age, age > 30, at today)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    @Test
    public void testIndexFunctionWithTimestamp() throws UnsupportedEncodingException, ParseException {
        String ccl = "avg(age, at today)";
        InputStream stream = new ByteArrayInputStream(ccl.getBytes(
                StandardCharsets.UTF_8.name()));
        Grammar grammar = new Grammar(stream, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION, visitor);
        grammar.generateAST();
    }

    /**
     * Constants
     */
    private static final String PAGE = "page";
    private static final String SIZE = "size";
    private static final String ORDER = "ORDER BY";

    /**
     * The canonical function to transform strings to java values in a
     * {@link Parser}.
     */
    public final Function<String, Object> PARSER_TRANSFORM_VALUE_FUNCTION = value -> Convert
            .stringToJava(value);

    /**
     * The canonical function to transform strings to operators in a
     * {@link Parser}.
     */
    public final Function<String, Operator> PARSER_TRANSFORM_OPERATOR_FUNCTION = operator -> Convert
            .stringToOperator(operator);

    public final GrammarVisitor visitor = new GrammarVisitor() {
        @Override
        public Object visit(SimpleNode node, Object data) {
            System.out.println(node + ": acceptor not unimplemented in subclass?");
            data = node.childrenAccept(this, data);
            return data;
        }

        @Override
        public Object visit(ASTStart node, Object data) {
            data = node.jjtGetChild(0).jjtAccept(this, data);
            return data;
        }

        @Override
        public Object visit(ASTOr node, Object data) {
            ConditionTree left = (ConditionTree) node.jjtGetChild(0).jjtAccept(this, data);
            ConditionTree right =(ConditionTree) node.jjtGetChild(1).jjtAccept(this, data);
            return new OrTree(left, right);
        }

        @Override
        public Object visit(ASTAnd node, Object data) {
            ConditionTree left = (ConditionTree) node.jjtGetChild(0).jjtAccept(this, data);
            ConditionTree right =(ConditionTree) node.jjtGetChild(1).jjtAccept(this, data);
            return new AndTree(left, right);
        }

        @Override
        public Object visit(ASTExpression node, Object data) {
            return new ExpressionTree(node);
        }

        @Override public Object visit(ASTOrder node, Object data) {
            return new OrderTree(node.order());
        }

        @Override
        public Object visit(ASTPage node, Object data) {
            return new PageTree(node.page());
        }

        @Override
        public Object visit(ASTFunction node, Object data) {
            return new FunctionTree(node.function());
        }
    };

}
/*
 * Copyright (c) 2013-2020 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl.grammar;

import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.common.base.AnyStrings;
import com.cinchapi.concourse.Tag;
import com.cinchapi.concourse.util.Random;

/**
 * Unit tests for {@link ValueSymbol}
 *
 * @author Jeff Nelson
 */
public class ValueSymbolTest {
    
    @Test
    public void testStringWithEqualSignIsQuoted() {
        String value = Random.getSimpleString()+"="+Random.getSimpleString();
        System.out.println(value);
        ValueSymbol symbol = new ValueSymbol(value);
        Assert.assertTrue(AnyStrings.isWithinQuotes(symbol.toString()));
    }
    
    @Test
    public void testTagWithEqualSignIsQuoted() {
        Tag value = Tag.create(Random.getSimpleString()+"="+Random.getSimpleString());
        System.out.println(value);
        ValueSymbol symbol = new ValueSymbol(value);
        Assert.assertTrue(AnyStrings.isWithinQuotes(symbol.toString()));
    }

}
/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl.util;

import org.joda.time.DateTime;
import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.concourse.Timestamp;

/**
 * Unit tests for the {@link NaturalLanguage} utils.
 *
 * @author Jeff Nelson
 */
public class NaturalLanguageTest  {

    @Test
    public void testParseTimeStringInDefaultFormat() {
        String str = "Sat Mar 07, 2015 @ 8:11:35:36 PM EST";
        long expected = Timestamp.parse(str, Timestamp.DEFAULT_FORMATTER)
                .getMicros();
        Assert.assertEquals(expected, NaturalLanguage.parseMicros(str));
    }
    
    @Test
    public void testParseTimeStringFormat1() {
        String string = "December 30, 1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(12, joda.getMonthOfYear());
        Assert.assertEquals(30, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat2() {
        String string = "Dec 30, 1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(12, joda.getMonthOfYear());
        Assert.assertEquals(30, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat3() {
        String string = "12/30/1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(12, joda.getMonthOfYear());
        Assert.assertEquals(30, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat10() {
        String string = "01-03-1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(1, joda.getMonthOfYear());
        Assert.assertEquals(3, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat11() {
        String string = "1-03-1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(1, joda.getMonthOfYear());
        Assert.assertEquals(3, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat12() {
        String string = "1-3-1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(1, joda.getMonthOfYear());
        Assert.assertEquals(3, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }
    
    @Test
    public void testParseTimeStringFormat13() {
        String string = "01-3-1987";
        Timestamp timestamp = Timestamp.fromMicros(NaturalLanguage.parseMicros(string));
        DateTime joda = timestamp.getJoda();
        Assert.assertEquals(1, joda.getMonthOfYear());
        Assert.assertEquals(3, joda.getDayOfMonth());
        Assert.assertEquals(1987, joda.getYear());
        Assert.assertEquals(0, joda.getHourOfDay());
        Assert.assertEquals(0, joda.getMinuteOfHour());
        Assert.assertEquals(0, joda.getSecondOfMinute());
    }

}/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import com.cinchapi.ccl.syntax.ConjunctionTree;
import com.cinchapi.ccl.syntax.ExpressionTree;
import com.cinchapi.ccl.syntax.FunctionTree;
import com.cinchapi.ccl.syntax.OrderTree;
import com.cinchapi.ccl.syntax.PageTree;

import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.ccl.grammar.ConjunctionSymbol;
import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ParenthesisSymbol;
import com.cinchapi.ccl.grammar.PostfixNotationSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.Symbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.CommandTree;
import com.cinchapi.ccl.syntax.Visitor;
import com.cinchapi.common.reflect.Reflection;
import com.cinchapi.concourse.Tag;
import com.cinchapi.concourse.Timestamp;
import com.cinchapi.concourse.lang.Criteria;
import com.cinchapi.concourse.thrift.Operator;
import com.cinchapi.concourse.time.Time;
import com.cinchapi.concourse.util.Random;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;

/**
 * Unit tests for {@link Parser} functionality.
 * 
 * @author Jeff Nelson
 * @deprecated Replaced by {@link CompilerTest}
 */
@Deprecated
public abstract class ParserTest {

    @Test
    public void testAbstractSyntaxTreeGenerationAndGroupOr() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 and (percent_undergrad_black >= 5 or total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationGroupAndOrGroupAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "(graduation_rate > 90 and yield_min = 20) or (percent_undergrad_black >= 5 and total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationGroupOrAndGroupOr() {
        doTestAbstractSyntaxTreeGeneration(
                "(graduation_rate > 90 or yield_min = 20) and (percent_undergrad_black >= 5 or total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationOrGroupAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 or (percent_undergrad_black >= 5 and total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationSimpleAndOr() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 AND percent_undergrad_black >= 5 OR total_cost_out_of_state > 50000");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationSimpleOrAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 OR percent_undergrad_black >= 5 AND total_cost_out_of_state > 50000");
    }

    @Test
    public void testGroupAnd() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).and().key(key1).operator(operator1).value(value1)
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym = (ConjunctionSymbol) symbols.get(1);
        ExpressionSymbol exp1 = (ExpressionSymbol) symbols.get(2);
        Assert.assertEquals(3, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(sym, ConjunctionSymbol.AND);
        Assert.assertEquals(exp1.raw().key(), key1);
        Assert.assertEquals(exp1.raw().operator(), operator1);
        Assert.assertEquals(exp1.values().get(0).value(), value1);
    }

    @Test
    public void testGroupOr() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).or().key(key1).operator(operator1).value(value1)
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym = (ConjunctionSymbol) symbols.get(1);
        ExpressionSymbol exp1 = (ExpressionSymbol) symbols.get(2);
        Assert.assertEquals(3, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(sym, ConjunctionSymbol.OR);
        Assert.assertEquals(exp1.raw().key(), key1);
        Assert.assertEquals(exp1.raw().operator(), operator1);
        Assert.assertEquals(exp1.values().get(0).value(), value1);
    }

    @Test
    public void testGroupSingle() {
        String key = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value = Random.getObject();
        Criteria criteria = Criteria.where().key(key).operator(operator)
                .value(value).build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp = (ExpressionSymbol) symbols.get(0);
        Assert.assertEquals(1, symbols.size());
        Assert.assertEquals(exp.raw().key(), key);
        Assert.assertEquals(exp.raw().operator(), operator);
        Assert.assertEquals(exp.values().get(0).value(), value);
    }

    @Test
    public void testGroupSingleBetween() {
        String key = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator = com.cinchapi.concourse.thrift.Operator.BETWEEN;
        Object value = Random.getObject();
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key).operator(operator)
                .value(value).value(value1).build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp = (ExpressionSymbol) symbols.get(0);
        Assert.assertEquals(1, symbols.size());
        Assert.assertEquals(exp.raw().key(), key);
        Assert.assertEquals(exp.raw().operator(), operator);
        Assert.assertEquals(exp.values().get(0).value(), value);
        Assert.assertEquals(exp.values().get(1).value(), value1);
    }

    @Test
    public void testGroupSub() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        String key2 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator2 = com.cinchapi.concourse.thrift.Operator.LESS_THAN;
        Object value2 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).and()
                .group(Criteria.where().key(key1).operator(operator1)
                        .value(value1).or().key(key2).operator(operator2)
                        .value(value2).build())
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym1 = (ConjunctionSymbol) symbols.get(1);
        ParenthesisSymbol sym2 = (ParenthesisSymbol) symbols.get(2);
        ExpressionSymbol exp3 = (ExpressionSymbol) symbols.get(3);
        ConjunctionSymbol sym4 = (ConjunctionSymbol) symbols.get(4);
        ExpressionSymbol exp5 = (ExpressionSymbol) symbols.get(5);
        ParenthesisSymbol sym6 = (ParenthesisSymbol) symbols.get(6);
        Assert.assertEquals(7, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(ConjunctionSymbol.AND, sym1);
        Assert.assertEquals(ParenthesisSymbol.LEFT, sym2);
        Assert.assertEquals(exp3.raw().key(), key1);
        Assert.assertEquals(exp3.raw().operator(), operator1);
        Assert.assertEquals(exp3.values().get(0).value(), value1);
        Assert.assertEquals(ConjunctionSymbol.OR, sym4);
        Assert.assertEquals(exp5.raw().key(), key2);
        Assert.assertEquals(exp5.raw().operator(), operator2);
        Assert.assertEquals(exp5.values().get(0).value(), value2);
        Assert.assertEquals(ParenthesisSymbol.RIGHT, sym6);
    }

    @Test(expected = SyntaxException.class)
    public void testGroupSyntaxException() {
        List<Symbol> symbols = Lists.<Symbol> newArrayList(new KeySymbol("foo"),
                new KeySymbol("bar"));
        Parsing.groupExpressions(symbols);
    }

    @Test
    public void testParseCclAndOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("1").and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).or().key("c")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(3).build();
        String ccl = "a = '1' and b = 2 or c = 3";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclBetween() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value("bar").value("baz").build();
        String ccl = "where foo bw bar baz";
        String ccl2 = "where foo >< bar baz";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
        Parser parser2 = createParser(ccl2);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser2.order());
    }

    @Test
    public void testParseCclBetweenWithBothReferences() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(30).value(35).build();
        String ccl = "where age bw $age $retireAge";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("retireAge", 35);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclBetweenWithFirstReference() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(30).value(100).build();
        String ccl = "where age bw $age 100";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclBetweenWithSecondReference() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(5).value(30).build();
        String ccl = "where age bw 5 $age";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCCLConjuctionsWithAnd() {
        String ccl = "name = chandresh pancholi on last christmas day && favovite_player != C. Ronaldo during last year";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; i++) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
            Assert.assertNotEquals(0, expr.raw().timestamp());
        }
    }

    @Test
    public void testParseCclGroupOrAndGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 or b = 2) AND (c = 3 or d = 4)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclGroupOrAndGroupOrConjuctions() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) && (c = 3 || d = 4)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());

    }

    @Test
    public void testParseCclGroupOrAndGroupOrConjuctionsWithSingleAmpersand() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) & (c = 3 || d = 4)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclGroupOrOrConjuction() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) || (c = 3 || d = 4)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclGroupOrOrGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 or b = 2) or (c = 3 or d = 4)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test(expected = SyntaxException.class)
    public void testParseCclInvalidReference() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("name", "King James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Parsing.toPostfixNotation(parser.tokenize());
    }

    @Test
    public void testParseCclLocalReferences() {
        Criteria criteria = Criteria.where().key("name")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("Lebron James").build();
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test(expected = IllegalStateException.class)
    public void testParseCclNoSpaces() {
        String ccl = "name=jeff";
        Parser parser = createParser(ccl);
        parser.order();
    }

    @Test(expected = SyntaxException.class)
    public void testParseCclReferenceNotFound() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Parser parser = createParser(ccl, data);
        Parsing.toPostfixNotation(parser.tokenize());
    }

    @Test
    public void testParseCclSimple() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("bar").build();
        String ccl = "where foo = bar";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());

    }

    @Test
    public void testParseCclSimpleAnd() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        String ccl = "a = 1 and b = 2";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclSimpleOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).or().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        String ccl = "a = 1 or b = 2";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testParseCclTimestampBasicPhrase() {
        String ccl = "name = jeff at \"now\"";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampComplexPhrase() {
        String ccl = "name = jeff at \"last christmas\"";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampNumericPhrase() {
        String ccl = "name = jeff at \"" + Time.now() + "\"";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampPhraseWithoutQuotes() {
        String ccl = "name = jeff at 3 seconds ago";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclValueAndTimestampPhraseWithoutQuotes() {
        String ccl = "name = jeff nelson on last christmas day";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("jeff nelson", expr.values().get(0).value());
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclValueAndTimestampPhraseWithoutQuotesAnd() {
        String ccl = "name = jeff nelson on last christmas day and favorite_player != Lebron James during last week";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; ++i) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
            Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                               // timestamp was
                                                               // parsed
        }
    }

    @Test
    public void testParseCclValueWithoutQuotes() {
        String ccl = "name = jeff nelson";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("jeff nelson", expr.values().get(0).value());
    }

    @Test
    public void testParseCclValueWithoutQuotesAnd() {
        String ccl = "name = jeff nelson and favorite_player != Lebron James";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; ++i) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
        }
    }

    @Test
    public void testParserAnalysisIncludesAllCriteriaKeys() {
        String ccl = "name = jeff and age = 100 and company = cinchapi or company = blavity";
        Parser parser = createParser(ccl);
        Assert.assertEquals(Sets.newHashSet("name", "age", "company"),
                parser.analyze().keys());;
    }

    @Test
    public void testPostfixNotationAndGroupOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and()
                .group(Criteria.where().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).or().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).build())
                .build();
        String ccl = "a = 1 and (b = 2 or c = 3)";
        Parser parser = createParser(ccl);
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                parser.order());
    }

    @Test
    public void testReproGH_113() {
        String ccl = "location = \"Atlanta (HQ)\"";
        Parser parser = createParser(ccl);
        Queue<PostfixNotationSymbol> symbols = parser.order();
        Assert.assertEquals(1, symbols.size());
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("Atlanta (HQ)", expr.raw().values().get(0));
    }

    @Test
    public void testToPostfixNotationAndGroupOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and()
                .group(Criteria.where().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).or().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 2)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(Iterables.get(pfn, 3), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 4), ConjunctionSymbol.AND);

    }

    @Test
    public void testToPostfixNotationAndOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).or().key("c")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(3).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 5);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.AND);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(Iterables.get(pfn, 4), ConjunctionSymbol.OR);
    }

    @Test
    public void testToPostfixNotationGroupOrAndGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 4)),
                ExpressionSymbol.create(new KeySymbol("d"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(4)));
        Assert.assertEquals(Iterables.get(pfn, 5), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 6), ConjunctionSymbol.AND);

    }

    @Test
    public void testToPostfixNotationGroupOrOrGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 4)),
                ExpressionSymbol.create(new KeySymbol("d"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(4)));
        Assert.assertEquals(Iterables.get(pfn, 5), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 6), ConjunctionSymbol.OR);

    }

    @Test
    public void testToPostfixNotationSimple() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("bar").build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 1);
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).key(),
                new KeySymbol("foo"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(0), new ValueSymbol("bar"));
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).operator(),
                new OperatorSymbol(
                        com.cinchapi.concourse.thrift.Operator.EQUALS));
    }

    @Test
    public void testToPostfixNotationSimpleAnd() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 3);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.AND);
    }

    @Test
    public void testToPostfixNotationSimpleBetween() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value("bar").value("baz").build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 1);
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).key(),
                new KeySymbol("foo"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(0), new ValueSymbol("bar"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(1), new ValueSymbol("baz"));
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).operator(),
                new OperatorSymbol(
                        com.cinchapi.concourse.thrift.Operator.BETWEEN));
    }

    @Test
    public void testToPostfixNotationSimpleOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).or().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 3);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
    }

    @Test
    public void testAnalyzeKeysOperator() {
        String ccl = "name = jeff AND company = Cinchapi and age > 20 or name != bob";
        Parser parser = createParser(ccl);
        Assert.assertEquals(Sets.newHashSet("name", "company"),
                parser.analyze().keys(Operator.EQUALS));
    }

    @Test
    public void testAnalyzeOperators() {
        String ccl = "name = jeff AND company = Cinchapi and age > 20 or name != bob";
        Parser parser = createParser(ccl);
        Assert.assertEquals(Sets.newHashSet(Operator.EQUALS,
                Operator.GREATER_THAN, Operator.NOT_EQUALS),
                parser.analyze().operators());
    }

    @Test
    public void testConjunctionPrecedence() {
        String ccl = "name = jeff OR name = bob AND age > 100";
        Parser parser = createParser(ccl);
        AbstractSyntaxTree ast = parser.parse();
        Assert.assertEquals(ConjunctionSymbol.OR, ast.root());
    }

    @Test
    public void testParseLinksTo() {
        String ccl1 = "friend lnk2 1";
        String ccl2 = "friend lnks2 1";
        String ccl3 = "friend -> 1";
        Parser parser1 = createParser(ccl1);
        Parser parser2 = createParser(ccl2);
        Parser parser3 = createParser(ccl3);
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO),
                parser1.analyze().operators());
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO),
                parser2.analyze().operators());
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO),
                parser3.analyze().operators());
    }

    @Test
    public void testParseLikeOperator() {
        String ccl = "email like %gmail%";
        Parser parser = createParser(ccl);
        Assert.assertEquals(Sets.newHashSet(Operator.LIKE),
                parser.analyze().operators());
    }

    @Test
    public void testTokenizeUnquotedValueStringWithSpace() {
        Criteria criteria = Criteria.where().key("name")
                .operator(Operator.EQUALS).value("Jeff Nelson").and()
                .group(Criteria.where().key("company").operator(Operator.EQUALS)
                        .value("Cinchapi").or().key("company")
                        .operator(Operator.EQUALS).value("Blavity"))
                .build();
        String ccl = criteria.ccl();
        Parser parser = createParser(ccl);
        List<Symbol> symbols = parser.tokenize();
        Assert.assertEquals(Lists.newArrayList(new KeySymbol("name"),
                new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Jeff Nelson"), ConjunctionSymbol.AND,
                ParenthesisSymbol.LEFT, new KeySymbol("company"),
                new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Cinchapi"), ConjunctionSymbol.OR,
                new KeySymbol("company"), new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Blavity"), ParenthesisSymbol.RIGHT), symbols);
    }

    @Test
    public void testParseSingleQuotedValue() {
        String ccl = "location = 'Atlanta (HQ)'";
        Parser parser = createParser(ccl);
        Assert.assertEquals("Atlanta (HQ)",
                ((ExpressionSymbol) parser.order().poll()).raw().values()
                        .get(0));
    }

    @Test
    public void testParseNumericString() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value("17").build();
        Parser parser = createParser(criteria.ccl());
        List<Symbol> tokens = parser.tokenize();
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(String.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNumericTag() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(Tag.create("17")).build();
        Parser parser = createParser(criteria.ccl());
        List<Symbol> tokens = parser.tokenize();
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNonNumericTag() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(Tag.create("bar")).build();
        Parser parser = createParser(criteria.ccl());
        List<Symbol> tokens = parser.tokenize();
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNumericNumber() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(17).build();
        Parser parser = createParser(criteria.ccl());
        List<Symbol> tokens = parser.tokenize();
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Integer.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testCriteriaWithTimestampValueParse() {
        Timestamp start = Timestamp.now();
        Timestamp end = Timestamp.now();
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.BETWEEN).value(start).value(end).build();
        Parser parser = createParser(criteria.ccl());
        int count = 0;
        for (Symbol symbol : parser.tokenize()) {
            if(symbol instanceof ValueSymbol) {
                ValueSymbol $symbol = (ValueSymbol) symbol;
                Assert.assertEquals(Timestamp.class,
                        $symbol.value().getClass());
                Assert.assertTrue($symbol.value().equals(start)
                        || $symbol.value().equals(end));
                ++count;
            }
        }
        Assert.assertEquals(2, count);
    }

    protected abstract Parser createParser(String ccl);

    protected abstract Parser createParser(String ccl,
            Multimap<String, Object> data);

    private void doTestAbstractSyntaxTreeGeneration(String ccl) {
        Parser parser = createParser(ccl);
        Visitor<Queue<Symbol>> visitor = new Visitor<Queue<Symbol>>() {

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(ConjunctionTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                tree.left().accept(this, data);
                tree.right().accept(this, data);
                queue.add(tree.root());
                return queue;
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(ExpressionTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                queue.add(tree.root());
                return queue;
            }

            @Override
            public Queue<Symbol> visit(CommandTree tree, Object... data) {
                // TODO Auto-generated method stub
                return null;
            }

            @Override
            public Queue<Symbol> visit(OrderTree tree, Object... data) {
                // TODO Auto-generated method stub
                return null;
            }

            @Override
            public Queue<Symbol> visit(PageTree tree, Object... data) {
                // TODO Auto-generated method stub
                return null;
            }

            @Override
            public Queue<Symbol> visit(FunctionTree tree,
                    Object... data) {
                // TODO Auto-generated method stub
                return null;
            }
        };
        Queue<Symbol> queue = parser.parse().accept(visitor,
                new LinkedList<Symbol>());
        Assert.assertEquals(queue, parser.order());
    }

}/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.syntax.ConditionTree;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.common.base.Array;
import com.cinchapi.common.function.TriFunction;
import com.cinchapi.concourse.thrift.TObject;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

/**
 * {@link CompilerTest} that uses the {@link JavaCCParser}
 * 
 * @author Jeff Nelson
 */
public class CompilerJavaCCTest extends AbstractCompilerTest {

    @Test
    public void testParseCclNoSpaces() {
        String ccl = "name=jeff";
        Compiler compiler = createCompiler();
        compiler.arrange((ConditionTree) compiler.parse(ccl));

        Assert.assertEquals(
                ExpressionSymbol.create(new KeySymbol("name"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol("jeff")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)).peek());
    }

    @Test
    public void testLocalEvaluationAnd() {
        String ccl = "a > 1 AND b bw 10 15";
        Compiler compiler = createCompiler(Convert::stringToJava,
                Convert::stringToOperator);
        Multimap<String, Object> passes = ImmutableMultimap.of("a", 5, "b", 12,
                "c", 4, "a", -1);
        TriFunction<Object, Operator, List<Object>, Boolean> evaluator = (value,
                operator, values) -> {
            TObject tvalue = Convert.javaToThrift(value);
            TObject[] tvalues = values.stream().map(Convert::javaToThrift)
                    .collect(Collectors.toList()).toArray(Array.containing());
            com.cinchapi.concourse.thrift.Operator toperator = Convert
                    .stringToOperator(operator.symbol());
            return tvalue.is(toperator, tvalues);
        };
        ConditionTree tree = (ConditionTree) compiler.parse(ccl);
        Assert.assertTrue(compiler.evaluate(tree, passes, evaluator));
        Multimap<String, Object> fails = ImmutableMultimap.of("a", 1, "b", 12,
                "c", 4, "a", -1);
        Assert.assertFalse(compiler.evaluate(tree, fails, evaluator));
        Multimap<String, Object> missing = ImmutableMultimap.of("a", 1, "c", 4,
                "a", -1);
        Assert.assertFalse(compiler.evaluate(tree, missing, evaluator));
    }

    @Test
    public void testLocalEvaluationOr() {
        String ccl = "a > 1 OR b bw 10 15";
        Compiler compiler = createCompiler(Convert::stringToJava,
                Convert::stringToOperator);
        TriFunction<Object, Operator, List<Object>, Boolean> evaluator = (value,
                operator, values) -> {
            TObject tvalue = Convert.javaToThrift(value);
            TObject[] tvalues = values.stream().map(Convert::javaToThrift)
                    .collect(Collectors.toList()).toArray(Array.containing());
            com.cinchapi.concourse.thrift.Operator toperator = Convert
                    .stringToOperator(operator.symbol());
            return tvalue.is(toperator, tvalues);
        };
        ConditionTree tree = (ConditionTree) compiler.parse(ccl);
        Multimap<String, Object> a = ImmutableMultimap.of("a", 5, "b", 12, "c",
                4, "a", -1);
        Assert.assertTrue(compiler.evaluate(tree, a, evaluator));
        Multimap<String, Object> b = ImmutableMultimap.of("a", 1, "b", 12, "c",
                4, "a", -1);
        Assert.assertTrue(compiler.evaluate(tree, b, evaluator));
        Multimap<String, Object> c = ImmutableMultimap.of("a", 2, "c", 4, "a",
                -1);
        Assert.assertTrue(compiler.evaluate(tree, c, evaluator));
        Multimap<String, Object> d = ImmutableMultimap.of("a", 1, "c", 4, "a",
                -1);
        Assert.assertFalse(compiler.evaluate(tree, d, evaluator));
    }
    
    @Test
    public void testRegressionV3_1_1A1() {
        String ccl = "(_ = com.cinchapi.runway.RunwayTest$Adult) AND (email LIKE %email.com%)";
        Compiler compiler = createCompiler();
        compiler.parse(ccl);
        Assert.assertTrue(true); // lack of Exception means the test passes
    }
    
    @Test
    public void testRegressionV3_1_1A2() {
        String ccl = "( _ = com.cinchapi.runway.RunwayTest$Adult ) AND ( email LIKE %email.com% )";
        Compiler compiler = createCompiler();
        compiler.parse(ccl);
        Assert.assertTrue(true); // lack of Exception means the test passes
    }

    @Test
    public void testRegressionV3_1_1A3() {
        String ccl = "( _ = com.cinchapi.runway.RunwayTest$Adult ) AND ( a regex b )";
        Compiler compiler = createCompiler();
        compiler.parse(ccl);
        Assert.assertTrue(true); // lack of Exception means the test passes
    }

    @Override
    protected Compiler createCompiler(
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction) {
        return Compiler.create(valueTransformFunction,
                operatorTransformFunction);
    }

}
/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import com.cinchapi.ccl.grammar.ConjunctionSymbol;
import com.cinchapi.ccl.grammar.DirectionSymbol;
import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionTokenSymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.OrderComponentSymbol;
import com.cinchapi.ccl.grammar.OrderSymbol;
import com.cinchapi.ccl.grammar.PageSymbol;
import com.cinchapi.ccl.grammar.ParenthesisSymbol;
import com.cinchapi.ccl.grammar.PostfixNotationSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.Symbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.AndTree;
import com.cinchapi.ccl.syntax.ConditionTree;
import com.cinchapi.ccl.syntax.ConjunctionTree;
import com.cinchapi.ccl.syntax.ExpressionTree;
import com.cinchapi.ccl.syntax.FunctionTree;
import com.cinchapi.ccl.syntax.OrTree;
import com.cinchapi.ccl.syntax.OrderTree;
import com.cinchapi.ccl.syntax.PageTree;
import com.cinchapi.ccl.syntax.CommandTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.type.function.IndexFunction;
import com.cinchapi.ccl.type.function.KeyConditionFunction;
import com.cinchapi.ccl.type.function.KeyRecordsFunction;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.ccl.type.function.ImplicitKeyRecordFunction;
import com.cinchapi.concourse.Tag;
import com.cinchapi.concourse.lang.Criteria;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import org.junit.Assert;
import org.junit.Test;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

/**
 * Tests for {@link JavaCCParser}.
 *
 * These tests include utput tests (postfix, abstract
 * syntax tree, tokens)
 */
public class CompilerJavaCCLogicTest {

    @Test
    public void testSingleExpressionTokenize() {
        String ccl = "a = 1";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleBinaryExpressionTokenize() {
        String ccl = "a >< 1 3";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("><")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleNRegexExpressionTokenize() {
        String ccl = "name nregex (?i:%jeff%)";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("name"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("nregex")));
        expectedTokens.add(new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("(?i:%jeff%)")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleLikeExpressionTokenize() {
        String ccl = "name like (?i:%jeff%)";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("name"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("like")));
        expectedTokens.add(new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("(?i:%jeff%)")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleConjunctionTokenize() {
        String ccl = "a = 1 and b = 2";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleDisjunctionTokenize() {
        String ccl = "a = 1 or b = 2";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDoubleConjunctionTokenize() {
        String ccl = "a = 1 and b = 2 and c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDoubleDisjunctionTokenize() {
        String ccl = "a = 1 or b = 2 or c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testConjunctionDisjunctionTokenize() {
        String ccl = "a = 1 and b = 2 or c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDisjunctionConjunctionTokenize() {
        String ccl = "a = 1 or b = 2 and c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionTokenize() {
        String ccl = "a = 1 and (b = 2 or c = 3)";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(ParenthesisSymbol.LEFT);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3")));
        expectedTokens.add(ParenthesisSymbol.RIGHT);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleConjunctionPostFix() {
        String ccl = "a = 1 and b = 2";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);
        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testSingleDisjunctionPostFix() {
        String ccl = "a = 1 or b = 2";
        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Queue<PostfixNotationSymbol> order = compiler
                .arrange((ConditionTree) ast);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDoubleConjunctionPostFix() {
        String ccl = "a = 1 and b = 2 and c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDoubleDisjunctionPostFix() {
        String ccl = "a = 1 or b = 2 or c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testConjunctionDisjunctionPostFix() {
        String ccl = "a = 1 and b = 2 or c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDisjunctionConjunctionPostFix() {
        String ccl = "a = 1 or b = 2 and c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);
        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionPostFix() {
        String ccl = "a = 1 or (b = 2 and c = 3)";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                COMPILER_PARSE_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);
        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ConditionTree tree = (ConditionTree) ast;
        Queue<PostfixNotationSymbol> order = compiler.arrange(tree);

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testSingleExpressionAbstractSyntaxTree() {
        String ccl = "a = 1";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());
    }

    @Test
    public void testSingleBinaryExpressionAbstractSyntaxTree() {
        String ccl = "a >< 1 2";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());
        Assert.assertEquals("2", expression.values().get(1).toString());
    }

    @Test
    public void testSingleConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ConjunctionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (((ConjunctionTree) tree)
                .right()).root();
        Assert.assertEquals("b", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("2", rightExpression.values().get(0).toString());
    }

    @Test
    public void testSingleDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Left node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("b", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("2", rightExpression.values().get(0).toString());
    }

    @Test
    public void testDoubleConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2 and c = 3";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof AndTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof AndTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", rightRightExpression.key().toString());
        Assert.assertEquals("=", rightRightExpression.operator().toString());
        Assert.assertEquals("2",
                rightRightExpression.values().get(0).toString());
    }

    @Test
    public void testDoubleDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2 or c = 3";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof OrTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("2",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testConjunctionDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2 or c = 3";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof AndTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("2",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testDisjunctionConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2 and c = 3";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Right node
        Assert.assertTrue(rootNode.right() instanceof AndTree);
        ConjunctionTree rightNode = (ConjunctionTree) rootNode.right();

        // right node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right left node
        Assert.assertTrue(rightNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightLeftExpression = (ExpressionSymbol) (rightNode
                .left()).root();
        Assert.assertEquals("b", rightLeftExpression.key().toString());
        Assert.assertEquals("=", rightLeftExpression.operator().toString());
        Assert.assertEquals("2",
                rightLeftExpression.values().get(0).toString());

        // Right right node
        Assert.assertTrue(rightNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightRightExpression = (ExpressionSymbol) (rightNode
                .right()).root();
        Assert.assertEquals("c", rightRightExpression.key().toString());
        Assert.assertEquals("=", rightRightExpression.operator().toString());
        Assert.assertEquals("3",
                rightRightExpression.values().get(0).toString());
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and (b = 2 or c = 3)";

        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);

        AbstractSyntaxTree ast = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(ast instanceof ConditionTree);
        Assert.assertTrue(ast instanceof AndTree);
        ConjunctionTree tree = (ConjunctionTree) ast;

        // Left node
        Assert.assertTrue(tree.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (tree.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right node
        Assert.assertTrue(tree.right() instanceof OrTree);
        ConjunctionTree rightNode = (ConjunctionTree) tree.right();

        // Right left node
        Assert.assertTrue(rightNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightLeftExpression = (ExpressionSymbol) (rightNode
                .left()).root();
        Assert.assertEquals("b", rightLeftExpression.key().toString());
        Assert.assertEquals("=", rightLeftExpression.operator().toString());
        Assert.assertEquals("2",
                rightLeftExpression.values().get(0).toString());

        // Right right node
        Assert.assertTrue(rightNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (rightNode
                .right()).root();
        Assert.assertEquals("c", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("3",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testParseCclLocalReferences() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl, data);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Lebron James\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testEscapedCclLocalReferences() {
        String ccl = "name = \\$name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl, data);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("$name", expression.values().get(0).toString());
    }

    @Test
    public void testDoubleQuotedValue() {
        String ccl = "name = \"Javier Lores\"";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Javier Lores\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testDoubleRightAndLeftQuotedValue() {
        String ccl = "name = “Javier Lores”";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Javier Lores\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testQuotedValueWithinQuotedString() {
        String ccl = "name = \"Javier \\\"Lores\"";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("'Javier \"Lores'",
                expression.values().get(0).toString());
    }

    @Test
    public void testNonQuoteEscapedValueWithinQuoteString() {
        String ccl = "name = \"Javier \\\"\\@Lores\"";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("'Javier \"\\@Lores'",
                expression.values().get(0).toString());
    }

    @Test
    public void validEscapedLocalResolution() {
        String ccl = "name = \\$name";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("$name", expression.values().get(0).toString());
    }

    @Test
    public void validEscapedImplicitLink() {
        String ccl = "name = \\@name";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("@name", expression.values().get(0).toString());
    }

    @Test
    public void testValidLink() {
        String ccl = "name -> 30";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("LINKS_TO", expression.operator().toString());
        Assert.assertEquals("30", expression.values().get(0).toString());
    }

    @Test
    public void validOperatorEnum() {
        String ccl = "name LINKS_TO 30";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("LINKS_TO", expression.operator().toString());
        Assert.assertEquals("30", expression.values().get(0).toString());
    }

    @Test
    public void testNavigationKey() {
        String ccl = "mother.children = 3";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother.children", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testLongNavigationKey() {
        String ccl = "mother.mother.siblings = 3";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother.mother.siblings",
                expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testPeriodSeparatedValue() {
        String ccl = "mother = a.b.c";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("a.b.c", expression.values().get(0).toString());
    }

    @Test
    public void testImplicitRecordFunctionAsEvaluationKey() {
        String ccl = "friends | avg > 3";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertTrue(expression.key() instanceof FunctionKeySymbol);
        FunctionKeySymbol symbol = expression.key();
        Assert.assertEquals("avg", symbol.key().operation());
        Assert.assertEquals("friends", symbol.key().key());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testImplicitIndexFunctionAsEvaluationValue() {
        String ccl = "age > avg(age)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((IndexFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((IndexFunction) expression.values().get(0).value()).key());
    }

    @Test
    public void testExplicitFunctionWithSingleRecordAsEvaluationValue() {
        String ccl = "age > avg(age, 1)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .key());
        Assert.assertEquals(1, ((List<Long>) ((KeyRecordsFunction) expression
                .values().get(0).value()).source()).size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(0));
    }

    @Test
    public void testExplicitFunctionWithBetween() {
        String ccl = "age bw avg(age) 1000";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((IndexFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((IndexFunction) expression.values().get(0).value()).key());

        Assert.assertEquals("1000", expression.values().get(1).toString());
    }

    @Test
    public void testExplicitFunctionWithBetweenCCL() {
        String ccl = "age bw avg(age, age > 10) 1000";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .key());

        Assert.assertTrue(
                (((KeyConditionFunction) expression.values().get(0).value())
                        .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).key()
                                .toString());
        Assert.assertEquals(">",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).operator()
                                .toString());
        Assert.assertEquals("10",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).values()
                                .get(0).toString());

        Assert.assertEquals("1000", expression.values().get(1).toString());
    }

    @Test
    public void testExplicitFunctionWithMultipleRecordsAsEvaluationValue() {
        String ccl = "age > avg(age, 1, 2)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .key());
        Assert.assertEquals(2, ((List<Long>) ((KeyRecordsFunction) expression
                .values().get(0).value()).source()).size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(0));
        Assert.assertEquals((long) 2,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(1));
    }

    @Test
    public void testExplicitFunctionWithCCLAsEvaluationValue() {
        String ccl = "age > avg(age, age < 30)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .key());

        Assert.assertTrue(
                (((KeyConditionFunction) expression.values().get(0).value())
                        .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).key()
                                .toString());
        Assert.assertEquals("<",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).operator()
                                .toString());
        Assert.assertEquals("30",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).values()
                                .get(0).toString());
    }

    @Test
    public void testValidImplicitRecordFunctionAsEvaluationKeyAndExplicitFunctionWithCCLAsEvaluationValue() {
        String ccl = "age | avg > avg(age, age < 30)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertTrue(expression.key() instanceof FunctionKeySymbol);
        Assert.assertEquals("avg",
                ((ImplicitKeyRecordFunction) expression.key().key())
                        .operation());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .key());

        Assert.assertTrue(
                (((KeyConditionFunction) expression.values().get(0).value())
                        .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).key()
                                .toString());
        Assert.assertEquals("<",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).operator()
                                .toString());
        Assert.assertEquals("30",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).values()
                                .get(0).toString());
    }

    @Test
    public void testPageWithNumber() {
        String input = PAGE + " 3";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new PageSymbol(3, null));

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testPageWithNumberAndSize() {
        String input = SIZE + " 1 " + PAGE + " 3";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new PageSymbol(3, 1));

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testPageWithSize() {
        String input = SIZE + " 3";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new PageSymbol(null, 3));

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testPageWithSizeAndNumber() {
        String input = SIZE + " 1 " + PAGE + " 3";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new PageSymbol(3, 1));

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testPageWithSizeAndNumberAST() {
        String input = SIZE + " 1 " + PAGE + " 3";

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(input);

        // Root node
        Assert.assertTrue(tree instanceof PageTree);

        PageSymbol page = (PageSymbol) tree.root();
        Assert.assertEquals(2, page.offset());
        Assert.assertEquals(1, page.limit());
    }

    @Test
    public void testSingleExpressionTokenizeWithPage() {
        String ccl = "a = 1 " + SIZE + " 3 " + PAGE + " 1 ";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(new PageSymbol(1, 3));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleExpressionASTWithPage() {
        String ccl = "a = 1 " + SIZE + " 1 " + PAGE + " 3 ";

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof CommandTree);
        CommandTree rootNode = (CommandTree) tree;

        Assert.assertTrue(rootNode.conditionTree() != null);
        ConditionTree conditionTree = rootNode.conditionTree();

        Assert.assertTrue(conditionTree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) conditionTree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());

        // Page Node
        Assert.assertTrue(((CommandTree) tree).pageTree() != null);
        PageSymbol page = (PageSymbol) ((CommandTree) tree).pageTree().root();
        Assert.assertEquals(2, page.offset());
        Assert.assertEquals(1, page.limit());
    }

    @Test
    public void testJsonReservedIdentifier() {
        String ccl = "$id$ != 40";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("$id$", expression.key().toString());
        Assert.assertEquals("!=", expression.operator().toString());
        Assert.assertEquals("40", expression.values().get(0).toString());
    }

    @Test
    public void testOrderKey() {
        String input = ORDER + " age";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyAscendingSymbol() {
        String input = ORDER + " < age";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyAscendingWord() {
        String input = ORDER + " age asc";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyDescendingSymbol() {
        String input = ORDER + " > age";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.DESCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyDescendingWord() {
        String input = ORDER + " age desc";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.DESCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithNumberTimestamp() {
        String input = ORDER + " age at " + String.valueOf(122L);

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(122L), DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithStringTimestamp() {
        String input = ORDER + " age during \"1992-10-02\"";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.DAYS),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithNumberTimestampAscending() {
        String input = ORDER + " < age on " + String.valueOf(122L);

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(122L), DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithStringTimestampAscending() {
        String input = ORDER + " < age during \"1992-10-02\"";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.DAYS),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithNumberTimestampDescending() {
        String input = ORDER + " > age during " + String.valueOf(122L);

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(122L), DirectionSymbol.DESCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderKeyWithStringTimestampDescending() {
        String input = ORDER + " > age in 1992-10-02";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                new TimestampSymbol(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.DAYS),
                DirectionSymbol.DESCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderMultipleKeys() {
        String input = ORDER + " age, salary";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        order.add(new OrderComponentSymbol(new KeySymbol("salary"),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderMultipleKeysWithDirectional() {
        String input = ORDER + " age asc, salary desc";

        // Build expected list
        List<Object> expectedTokens = Lists.newArrayList();

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        order.add(new OrderComponentSymbol(new KeySymbol("salary"),
                DirectionSymbol.DESCENDING));
        expectedTokens.add(order);

        // Generate list
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderMultipleKeysWithDirectionalAST() {
        String input = ORDER + " < age, > salary";

        OrderSymbol expectedOrder = new OrderSymbol();
        expectedOrder.add(new OrderComponentSymbol(new KeySymbol("age"),
                DirectionSymbol.ASCENDING));
        expectedOrder.add(new OrderComponentSymbol(new KeySymbol("salary"),
                DirectionSymbol.DESCENDING));

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(input);

        // Root node
        Assert.assertTrue(ast instanceof OrderTree);

        // Order Node
        OrderSymbol order = (OrderSymbol) ((OrderTree) ast).root();
        Assert.assertEquals(order, expectedOrder);
    }

    @Test
    public void testOrderSingleExpressionWithOrderTokenize() {
        String ccl = "a = 1 " + ORDER + " a";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                COMPILER_PARSE_OPERATOR_FUNCTION.apply("=")));
        expectedTokens
                .add(new ValueSymbol(COMPILER_PARSE_VALUE_FUNCTION.apply("1")));

        OrderSymbol order = new OrderSymbol();
        order.add(new OrderComponentSymbol(new KeySymbol("a"),
                DirectionSymbol.ASCENDING));
        expectedTokens.add(order);

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testOrderSingleExpressionWithOrderAbstractSyntaxTree() {
        String ccl = "a = 1 " + ORDER + " a";

        OrderSymbol expectedOrder = new OrderSymbol();
        expectedOrder.add(new OrderComponentSymbol(new KeySymbol("a"),
                DirectionSymbol.ASCENDING));

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof CommandTree);
        CommandTree rootNode = (CommandTree) tree;

        Assert.assertTrue(rootNode.conditionTree() != null);
        ConditionTree conditionTree = rootNode.conditionTree();

        Assert.assertTrue(conditionTree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) conditionTree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());

        // Order Node
        Assert.assertTrue(((CommandTree) tree).orderTree() != null);
        OrderSymbol order = (OrderSymbol) ((CommandTree) tree).orderTree()
                .root();
        Assert.assertEquals(order, expectedOrder);
    }

    @Test
    public void testOrderSingleExpressionWithOrderAndPageAbstractSyntaxTree() {
        String ccl = "a = 1 " + ORDER + " a " + SIZE + " 1 " + PAGE + " 3";

        OrderSymbol expectedOrder = new OrderSymbol();
        expectedOrder.add(new OrderComponentSymbol(new KeySymbol("a"),
                DirectionSymbol.ASCENDING));

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof CommandTree);
        CommandTree rootNode = (CommandTree) tree;

        Assert.assertTrue(rootNode.conditionTree() != null);
        ConditionTree conditionTree = rootNode.conditionTree();

        Assert.assertTrue(conditionTree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) conditionTree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());

        // Order Node
        Assert.assertTrue(((CommandTree) tree).orderTree() != null);
        OrderSymbol order = (OrderSymbol) ((CommandTree) tree).orderTree()
                .root();
        Assert.assertEquals(order, expectedOrder);

        // Page Node
        Assert.assertTrue(((CommandTree) tree).pageTree() != null);
        PageSymbol page = (PageSymbol) ((CommandTree) tree).pageTree().root();
        Assert.assertEquals(2, page.offset());
        Assert.assertEquals(1, page.limit());
    }

    @Test
    public void testImplicitKeyRecordFunctionTokenize() {
        String ccl = "age | avg";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new FunctionKeySymbol(
                new ImplicitKeyRecordFunction("avg", "age")));

        // Generate queue
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(ccl);
        List<Symbol> tokens = compiler.tokenize(ast);

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testImplicitKeyRecordFunctionAbstractSyntaxTree() {
        String ccl = "age | avg";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);

        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();
        Assert.assertEquals("age", symbol.function().key());
        Assert.assertEquals("avg", symbol.function().operation());
    }

    @Test
    public void testIndexFunctionAbstractSyntaxTree() {
        String ccl = "avg(age)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);

        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();
        Assert.assertEquals(IndexFunction.class, symbol.function().getClass());
        Assert.assertEquals("age", symbol.function().key());
        Assert.assertEquals("avg", symbol.function().operation());
    }

    @Test
    public void testKeyCclFunctionAbstractSyntaxTree() {
        String ccl = "avg(age, age > 3)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((KeyConditionFunction) symbol.function()).operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) symbol.function()).key());

        Assert.assertTrue((((KeyConditionFunction) symbol.function())
                .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).key().toString());
        Assert.assertEquals(">",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).operator().toString());
        Assert.assertEquals("3",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).values().get(0)
                                .toString());
    }

    @Test
    public void testKeyCclFunctionWithTimestampAbstractSyntaxTree() {
        String ccl = "avg(age, age > 3, in 1992-10-02)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((KeyConditionFunction) symbol.function()).operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) symbol.function()).key());

        Assert.assertTrue((((KeyConditionFunction) symbol.function())
                .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).key().toString());
        Assert.assertEquals(">",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).operator().toString());
        Assert.assertEquals("3",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) symbol
                        .function()).source()).root()).values().get(0)
                                .toString());
        Assert.assertEquals(
                TimeUnit.DAYS.convert(
                        ((KeyConditionFunction) symbol.function()).timestamp(),
                        TimeUnit.MICROSECONDS),
                TimeUnit.DAYS.convert(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.MICROSECONDS));
    }

    @Test
    public void testKeyRecordsFunctionAbstractSyntaxTree() {
        String ccl = "avg(age, 1)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((KeyRecordsFunction) symbol.function()).operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) symbol.function()).key());

        Assert.assertEquals(1,
                ((List<Long>) ((KeyRecordsFunction) symbol.function()).source())
                        .size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) symbol.function())
                        .source()).get(0));
    }

    @Test
    public void testKeyMultiRecordsFunctionAbstractSyntaxTree() {
        String ccl = "avg(age, 1,2,3,5,11)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((KeyRecordsFunction) symbol.function()).operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) symbol.function()).key());

        Assert.assertEquals(5,
                ((List<Long>) ((KeyRecordsFunction) symbol.function()).source())
                        .size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) symbol.function())
                        .source()).get(0));
    }

    @Test
    public void testKeyMultiRecordsFunctionWithTimestampAbstractSyntaxTree() {
        String ccl = "avg(age, [1,2,3,5,11], in 1992-10-02)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((KeyRecordsFunction) symbol.function()).operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) symbol.function()).key());

        Assert.assertEquals(5,
                ((List<Long>) ((KeyRecordsFunction) symbol.function()).source())
                        .size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) symbol.function())
                        .source()).get(0));
        Assert.assertEquals(
                TimeUnit.DAYS.convert(
                        ((KeyRecordsFunction) symbol.function()).timestamp(),
                        TimeUnit.MICROSECONDS),
                TimeUnit.DAYS.convert(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.MICROSECONDS));
    }

    @Test
    public void testIndexFunctionWithTimestampAbstractSyntaxTree() {
        String ccl = "avg(age, in 1992-10-02)";

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = compiler.parse(ccl);

        // Root node
        Assert.assertTrue(tree instanceof FunctionTree);
        FunctionTokenSymbol symbol = (FunctionTokenSymbol) tree.root();

        Assert.assertEquals("avg",
                ((IndexFunction) symbol.function()).operation());
        Assert.assertEquals("age", ((IndexFunction) symbol.function()).key());

        Assert.assertEquals(
                TimeUnit.DAYS.convert(
                        ((IndexFunction) symbol.function()).timestamp(),
                        TimeUnit.MICROSECONDS),
                TimeUnit.DAYS.convert(NaturalLanguage.parseMicros("1992-10-02"),
                        TimeUnit.MICROSECONDS));
    }

    @Test
    public void testReproIX5A() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("_")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value("org.internx.model.data.user.Student"))
                .and()
                .group(Criteria.where()
                        .group(Criteria.where().key("group").operator(
                                com.cinchapi.concourse.thrift.Operator.LIKE)
                                .value("%Accounting And Business/management%"))
                        .or()
                        .group(Criteria.where().key("major").operator(
                                com.cinchapi.concourse.thrift.Operator.LIKE)
                                .value("%accounting and business/management%")));

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(criteria.ccl());
        List<Symbol> tokens = compiler.tokenize(ast);
        tokens.forEach(token -> {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(String.class,
                        ((ValueSymbol) token).value().getClass());
            }
        });
    }

    @Test
    public void testReproIX5B() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("_")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(Tag
                                .create("org.internx.model.data.user.Student")))
                .and()
                .group(Criteria.where().group(Criteria.where().key("group")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(Tag
                                .create("Accounting And Business/management")))
                        .or()
                        .group(Criteria.where().key("major").operator(
                                com.cinchapi.concourse.thrift.Operator.EQUALS)
                                .value(Tag.create(
                                        "accounting and business/management"))));

        // Generate tree
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        AbstractSyntaxTree ast = compiler.parse(criteria.ccl());
        List<Symbol> tokens = compiler.tokenize(ast);
        tokens.forEach(token -> {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        });
    }

    @Test
    public void testRegressionV3_1_1A() {
        String ccl = "(a = b) or c = d and (email like email.com)";
        Compiler compiler = Compiler.create(COMPILER_PARSE_VALUE_FUNCTION,
                COMPILER_PARSE_OPERATOR_FUNCTION);
        compiler.parse(ccl);
        Assert.assertTrue(true); // lack of Exception means the test passes
    }

    /**
     * Constants
     */
    private static final String PAGE = "page";
    private static final String SIZE = "size";
    private static final String ORDER = "order by";

    /**
     * The canonical function to transform strings to java values in a
     * {@link Parser}.
     */
    public final Function<String, Object> COMPILER_PARSE_VALUE_FUNCTION = value -> Convert
            .stringToJava(value);

    /**
     * The canonical function to transform strings to operators in a
     * {@link Parser}.
     */
    public final Function<String, Operator> COMPILER_PARSE_OPERATOR_FUNCTION = operator -> Convert
            .stringToOperator(operator);

    /**
     *
     */
    @SuppressWarnings("unused")
    private void printPreOrder(AbstractSyntaxTree tree) {
        System.out.println(tree.root());
        for (AbstractSyntaxTree child : tree.children()) {
            printPreOrder(child);
        }
    }
}
/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.TimeUnit;

import com.cinchapi.ccl.syntax.ConjunctionTree;
import com.cinchapi.ccl.syntax.ExpressionTree;
import com.cinchapi.ccl.syntax.FunctionTree;
import com.cinchapi.ccl.syntax.OrderTree;
import com.cinchapi.ccl.syntax.PageTree;
import com.cinchapi.ccl.syntax.CommandTree;
import com.cinchapi.ccl.syntax.ConditionTree;
import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.ccl.grammar.ConjunctionSymbol;
import com.cinchapi.ccl.grammar.DirectionSymbol;
import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.OrderComponentSymbol;
import com.cinchapi.ccl.grammar.OrderSymbol;
import com.cinchapi.ccl.grammar.ParenthesisSymbol;
import com.cinchapi.ccl.grammar.PostfixNotationSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.Symbol;
import com.cinchapi.ccl.grammar.TimestampSymbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.Visitor;
import com.cinchapi.ccl.util.NaturalLanguage;
import com.cinchapi.common.reflect.Reflection;
import com.cinchapi.concourse.Tag;
import com.cinchapi.concourse.Timestamp;
import com.cinchapi.concourse.lang.Criteria;
import com.cinchapi.concourse.thrift.Operator;
import com.cinchapi.concourse.time.Time;
import com.cinchapi.concourse.util.Random;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;

/**
 * Unit tests for {@link Compiler} functionality.
 * 
 * @author Jeff Nelson
 */
public abstract class CompilerTest {

    @Test
    public void testAbstractSyntaxTreeGenerationAndGroupOr() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 and (percent_undergrad_black >= 5 or total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationGroupAndOrGroupAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "(graduation_rate > 90 and yield_min = 20) or (percent_undergrad_black >= 5 and total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationGroupOrAndGroupOr() {
        doTestAbstractSyntaxTreeGeneration(
                "(graduation_rate > 90 or yield_min = 20) and (percent_undergrad_black >= 5 or total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationOrGroupAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 or (percent_undergrad_black >= 5 and total_cost_out_state > 50000)");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationSimpleAndOr() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 AND percent_undergrad_black >= 5 OR total_cost_out_of_state > 50000");
    }

    @Test
    public void testAbstractSyntaxTreeGenerationSimpleOrAnd() {
        doTestAbstractSyntaxTreeGeneration(
                "graduation_rate > 90 OR percent_undergrad_black >= 5 AND total_cost_out_of_state > 50000");
    }

    @Test
    public void testGroupAnd() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).and().key(key1).operator(operator1).value(value1)
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym = (ConjunctionSymbol) symbols.get(1);
        ExpressionSymbol exp1 = (ExpressionSymbol) symbols.get(2);
        Assert.assertEquals(3, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(sym, ConjunctionSymbol.AND);
        Assert.assertEquals(exp1.raw().key(), key1);
        Assert.assertEquals(exp1.raw().operator(), operator1);
        Assert.assertEquals(exp1.values().get(0).value(), value1);
    }

    @Test
    public void testGroupOr() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).or().key(key1).operator(operator1).value(value1)
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym = (ConjunctionSymbol) symbols.get(1);
        ExpressionSymbol exp1 = (ExpressionSymbol) symbols.get(2);
        Assert.assertEquals(3, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(sym, ConjunctionSymbol.OR);
        Assert.assertEquals(exp1.raw().key(), key1);
        Assert.assertEquals(exp1.raw().operator(), operator1);
        Assert.assertEquals(exp1.values().get(0).value(), value1);
    }

    @Test
    public void testGroupSingle() {
        String key = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value = Random.getObject();
        Criteria criteria = Criteria.where().key(key).operator(operator)
                .value(value).build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp = (ExpressionSymbol) symbols.get(0);
        Assert.assertEquals(1, symbols.size());
        Assert.assertEquals(exp.raw().key(), key);
        Assert.assertEquals(exp.raw().operator(), operator);
        Assert.assertEquals(exp.values().get(0).value(), value);
    }

    @Test
    public void testGroupSingleBetween() {
        String key = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator = com.cinchapi.concourse.thrift.Operator.BETWEEN;
        Object value = Random.getObject();
        Object value1 = Random.getObject();
        Criteria criteria = Criteria.where().key(key).operator(operator)
                .value(value).value(value1).build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp = (ExpressionSymbol) symbols.get(0);
        Assert.assertEquals(1, symbols.size());
        Assert.assertEquals(exp.raw().key(), key);
        Assert.assertEquals(exp.raw().operator(), operator);
        Assert.assertEquals(exp.values().get(0).value(), value);
        Assert.assertEquals(exp.values().get(1).value(), value1);
    }

    @Test
    public void testGroupSub() {
        String key0 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator0 = com.cinchapi.concourse.thrift.Operator.EQUALS;
        Object value0 = Random.getObject();
        String key1 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator1 = com.cinchapi.concourse.thrift.Operator.GREATER_THAN;
        Object value1 = Random.getObject();
        String key2 = Random.getString();
        com.cinchapi.concourse.thrift.Operator operator2 = com.cinchapi.concourse.thrift.Operator.LESS_THAN;
        Object value2 = Random.getObject();
        Criteria criteria = Criteria.where().key(key0).operator(operator0)
                .value(value0).and()
                .group(Criteria.where().key(key1).operator(operator1)
                        .value(value1).or().key(key2).operator(operator2)
                        .value(value2).build())
                .build();
        List<Symbol> symbols = Parsing
                .groupExpressions(Reflection.call(criteria, "symbols"));
        ExpressionSymbol exp0 = (ExpressionSymbol) symbols.get(0);
        ConjunctionSymbol sym1 = (ConjunctionSymbol) symbols.get(1);
        ParenthesisSymbol sym2 = (ParenthesisSymbol) symbols.get(2);
        ExpressionSymbol exp3 = (ExpressionSymbol) symbols.get(3);
        ConjunctionSymbol sym4 = (ConjunctionSymbol) symbols.get(4);
        ExpressionSymbol exp5 = (ExpressionSymbol) symbols.get(5);
        ParenthesisSymbol sym6 = (ParenthesisSymbol) symbols.get(6);
        Assert.assertEquals(7, symbols.size());
        Assert.assertEquals(exp0.raw().key(), key0);
        Assert.assertEquals(exp0.raw().operator(), operator0);
        Assert.assertEquals(exp0.values().get(0).value(), value0);
        Assert.assertEquals(ConjunctionSymbol.AND, sym1);
        Assert.assertEquals(ParenthesisSymbol.LEFT, sym2);
        Assert.assertEquals(exp3.raw().key(), key1);
        Assert.assertEquals(exp3.raw().operator(), operator1);
        Assert.assertEquals(exp3.values().get(0).value(), value1);
        Assert.assertEquals(ConjunctionSymbol.OR, sym4);
        Assert.assertEquals(exp5.raw().key(), key2);
        Assert.assertEquals(exp5.raw().operator(), operator2);
        Assert.assertEquals(exp5.values().get(0).value(), value2);
        Assert.assertEquals(ParenthesisSymbol.RIGHT, sym6);
    }

    @Test(expected = SyntaxException.class)
    public void testGroupSyntaxException() {
        List<Symbol> symbols = Lists.<Symbol> newArrayList(new KeySymbol("foo"),
                new KeySymbol("bar"));
        Parsing.groupExpressions(symbols);
    }

    @Test
    public void testParseCclAndOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("1").and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).or().key("c")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(3).build();
        String ccl = "a = '1' and b = 2 or c = 3";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclBetween() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value("bar").value("baz").build();
        String ccl = "where foo bw bar baz";
        String ccl2 = "where foo >< bar baz";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl2)));
    }

    @Test
    public void testParseCclBetweenWithBothReferences() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(30).value(35).build();
        String ccl = "where age bw $age $retireAge";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("retireAge", 35);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl, data)));
    }

    @Test
    public void testParseCclBetweenWithFirstReference() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(30).value(100).build();
        String ccl = "where age bw $age 100";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl, data)));
    }

    @Test
    public void testParseCclBetweenWithSecondReference() {
        Criteria criteria = Criteria.where().key("age")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value(5).value(30).build();
        String ccl = "where age bw 5 $age";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl, data)));
    }

    @Test
    public void testParseCCLConjuctionsWithAnd() {
        String ccl = "name = chandresh pancholi on last christmas day && favovite_player != C. Ronaldo during last year";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; i++) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
            Assert.assertNotEquals(0, expr.raw().timestamp());
        }
    }

    @Test
    public void testParseCclGroupOrAndGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 or b = 2) AND (c = 3 or d = 4)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclGroupOrAndGroupOrConjuctions() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) && (c = 3 || d = 4)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));

    }

    @Test
    public void testParseCclGroupOrAndGroupOrConjuctionsWithSingleAmpersand() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) & (c = 3 || d = 4)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclGroupOrOrConjuction() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 || b = 2) || (c = 3 || d = 4)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclGroupOrOrGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        String ccl = "(a = 1 or b = 2) or (c = 3 or d = 4)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test(expected = SyntaxException.class)
    public void testParseCclInvalidReference() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("name", "King James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Parsing.toPostfixNotation(compiler.tokenize(compiler.parse(ccl, data)));
    }

    @Test
    public void testParseCclLocalReferences() {
        Criteria criteria = Criteria.where().key("name")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("Lebron James").build();
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl, data)));
    }

    @Test(expected = IllegalStateException.class)
    public void testParseCclNoSpaces() {
        String ccl = "name=jeff";
        Compiler compiler = createCompiler();
        compiler.arrange((ConditionTree) compiler.parse(ccl));
    }

    @Test(expected = SyntaxException.class)
    public void testParseCclReferenceNotFound() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");
        Compiler compiler = createCompiler();
        Parsing.toPostfixNotation(compiler.tokenize(compiler.parse(ccl, data)));
    }

    @Test
    public void testParseCclSimple() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("bar").build();
        String ccl = "where foo = bar";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));

    }

    @Test
    public void testParseCclSimpleAnd() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        String ccl = "a = 1 and b = 2";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclSimpleOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).or().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        String ccl = "a = 1 or b = 2";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testParseCclTimestampBasicPhrase() {
        String ccl = "name = jeff at \"now\"";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampComplexPhrase() {
        String ccl = "name = jeff at \"last christmas\"";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampNumericPhrase() {
        String ccl = "name = jeff at \"" + Time.now() + "\"";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclTimestampPhraseWithoutQuotes() {
        String ccl = "name = jeff at 3 seconds ago";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclValueAndTimestampPhraseWithoutQuotes() {
        String ccl = "name = jeff nelson on last christmas day";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("jeff nelson", expr.values().get(0).value());
        Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                           // timestamp was
                                                           // parsed
    }

    @Test
    public void testParseCclValueAndTimestampPhraseWithoutQuotesAnd() {
        String ccl = "name = jeff nelson on last christmas day and favorite_player != Lebron James during last week";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; ++i) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
            Assert.assertNotEquals(0, expr.raw().timestamp()); // this means a
                                                               // timestamp was
                                                               // parsed
        }
    }

    @Test
    public void testParseCclValueWithoutQuotes() {
        String ccl = "name = jeff nelson";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("jeff nelson", expr.values().get(0).value());
    }

    @Test
    public void testParseCclValueWithoutQuotesAnd() {
        String ccl = "name = jeff nelson and favorite_player != Lebron James";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        Assert.assertEquals(3, symbols.size());
        for (int i = 0; i < 2; ++i) {
            ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
            Assert.assertTrue(
                    expr.values().get(0).value().toString().contains(" "));
        }
    }

    @Test
    public void testParserAnalysisIncludesAllCriteriaKeys() {
        String ccl = "name = jeff and age = 100 and company = cinchapi or company = blavity";
        Compiler compiler = createCompiler();
        Assert.assertEquals(Sets.newHashSet("name", "age", "company"),
                compiler.analyze((ConditionTree) compiler.parse(ccl)).keys());
    }

    @Test
    public void testPostfixNotationAndGroupOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and()
                .group(Criteria.where().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).or().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).build())
                .build();
        String ccl = "a = 1 and (b = 2 or c = 3)";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Parsing.toPostfixNotation(Reflection.call(criteria, "symbols")),
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

    @Test
    public void testReproGH_113() {
        String ccl = "location = \"Atlanta (HQ)\"";
        Compiler compiler = createCompiler();
        Queue<PostfixNotationSymbol> symbols = compiler
                .arrange((ConditionTree) compiler.parse(ccl));
        Assert.assertEquals(1, symbols.size());
        ExpressionSymbol expr = (ExpressionSymbol) symbols.poll();
        Assert.assertEquals("Atlanta (HQ)", expr.raw().values().get(0));
    }

    @Test
    public void testToPostfixNotationAndGroupOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and()
                .group(Criteria.where().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).or().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 2)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(Iterables.get(pfn, 3), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 4), ConjunctionSymbol.AND);

    }

    @Test
    public void testToPostfixNotationAndOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).or().key("c")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(3).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 5);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.AND);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(Iterables.get(pfn, 4), ConjunctionSymbol.OR);
    }

    @Test
    public void testToPostfixNotationGroupOrAndGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .and()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 4)),
                ExpressionSymbol.create(new KeySymbol("d"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(4)));
        Assert.assertEquals(Iterables.get(pfn, 5), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 6), ConjunctionSymbol.AND);

    }

    @Test
    public void testToPostfixNotationGroupOrOrGroupOr() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("a")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(1).or().key("b")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(2).build())
                .or()
                .group(Criteria.where().key("c")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(3).or().key("d")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(4).build())
                .build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 3)),
                ExpressionSymbol.create(new KeySymbol("c"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(3)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 4)),
                ExpressionSymbol.create(new KeySymbol("d"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(4)));
        Assert.assertEquals(Iterables.get(pfn, 5), ConjunctionSymbol.OR);
        Assert.assertEquals(Iterables.get(pfn, 6), ConjunctionSymbol.OR);

    }

    @Test
    public void testToPostfixNotationSimple() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value("bar").build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 1);
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).key(),
                new KeySymbol("foo"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(0), new ValueSymbol("bar"));
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).operator(),
                new OperatorSymbol(
                        com.cinchapi.concourse.thrift.Operator.EQUALS));
    }

    @Test
    public void testToPostfixNotationSimpleAnd() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).and().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 3);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.AND);
    }

    @Test
    public void testToPostfixNotationSimpleBetween() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(com.cinchapi.concourse.thrift.Operator.BETWEEN)
                .value("bar").value("baz").build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 1);
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).key(),
                new KeySymbol("foo"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(0), new ValueSymbol("bar"));
        Assert.assertEquals(((ExpressionSymbol) Iterables.getOnlyElement(pfn))
                .values().get(1), new ValueSymbol("baz"));
        Assert.assertEquals(
                ((ExpressionSymbol) Iterables.getOnlyElement(pfn)).operator(),
                new OperatorSymbol(
                        com.cinchapi.concourse.thrift.Operator.BETWEEN));
    }

    @Test
    public void testToPostfixNotationSimpleOr() {
        Criteria criteria = Criteria.where().key("a")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(1).or().key("b")
                .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                .value(2).build();
        Queue<PostfixNotationSymbol> pfn = Parsing
                .toPostfixNotation(Reflection.call(criteria, "symbols"));
        Assert.assertEquals(pfn.size(), 3);
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 0)),
                ExpressionSymbol.create(new KeySymbol("a"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(1)));
        Assert.assertEquals(((ExpressionSymbol) Iterables.get(pfn, 1)),
                ExpressionSymbol.create(new KeySymbol("b"),
                        new OperatorSymbol(
                                com.cinchapi.concourse.thrift.Operator.EQUALS),
                        new ValueSymbol(2)));
        Assert.assertEquals(Iterables.get(pfn, 2), ConjunctionSymbol.OR);
    }

    @Test
    public void testAnalyzeKeysOperator() {
        String ccl = "name = jeff AND company = Cinchapi and age > 20 or name != bob";
        Compiler compiler = createCompiler();
        Assert.assertEquals(Sets.newHashSet("name", "company"),
                compiler.analyze((ConditionTree) compiler.parse(ccl))
                        .keys(Operator.EQUALS));
    }

    @Test
    public void testAnalyzeOperators() {
        String ccl = "name = jeff AND company = Cinchapi and age > 20 or name != bob";
        Compiler compiler = createCompiler();
        Assert.assertEquals(
                Sets.newHashSet(Operator.EQUALS, Operator.GREATER_THAN,
                        Operator.NOT_EQUALS),
                compiler.analyze((ConditionTree) compiler.parse(ccl))
                        .operators());
    }

    @Test
    public void testConjunctionPrecedence() {
        String ccl = "name = jeff OR name = bob AND age > 100";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertEquals(ConjunctionSymbol.OR, ast.root());
    }

    @Test
    public void testParseLinksTo() {
        String ccl1 = "friend lnk2 1";
        String ccl2 = "friend lnks2 1";
        String ccl3 = "friend -> 1";
        Compiler compiler = createCompiler();
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO), compiler
                .analyze((ConditionTree) compiler.parse(ccl1)).operators());
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO), compiler
                .analyze((ConditionTree) compiler.parse(ccl2)).operators());
        Assert.assertEquals(Sets.newHashSet(Operator.LINKS_TO), compiler
                .analyze((ConditionTree) compiler.parse(ccl3)).operators());
    }

    @Test
    public void testParseLikeOperator() {
        String ccl = "email like %gmail%";
        Compiler compiler = createCompiler();
        Assert.assertEquals(Sets.newHashSet(Operator.LIKE), compiler
                .analyze((ConditionTree) compiler.parse(ccl)).operators());
    }

    @Test
    public void testTokenizeUnquotedValueStringWithSpace() {
        Criteria criteria = Criteria.where().key("name")
                .operator(Operator.EQUALS).value("Jeff Nelson").and()
                .group(Criteria.where().key("company").operator(Operator.EQUALS)
                        .value("Cinchapi").or().key("company")
                        .operator(Operator.EQUALS).value("Blavity"))
                .build();
        String ccl = criteria.ccl();
        Compiler compiler = createCompiler();
        List<Symbol> symbols = compiler.tokenize(compiler.parse(ccl));
        Assert.assertEquals(Lists.newArrayList(new KeySymbol("name"),
                new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Jeff Nelson"), ConjunctionSymbol.AND,
                ParenthesisSymbol.LEFT, new KeySymbol("company"),
                new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Cinchapi"), ConjunctionSymbol.OR,
                new KeySymbol("company"), new OperatorSymbol(Operator.EQUALS),
                new ValueSymbol("Blavity"), ParenthesisSymbol.RIGHT), symbols);
    }

    @Test
    public void testParseSingleQuotedValue() {
        String ccl = "location = 'Atlanta (HQ)'";
        Compiler compiler = createCompiler();
        Assert.assertEquals("Atlanta (HQ)",
                ((ExpressionSymbol) compiler
                        .arrange((ConditionTree) compiler.parse(ccl)).poll())
                                .raw().values().get(0));
    }

    @Test
    public void testParseNumericString() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value("17").build();
        Compiler compiler = createCompiler();
        List<Symbol> tokens = compiler.tokenize(compiler.parse(criteria.ccl()));
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(String.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNumericTag() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(Tag.create("17")).build();
        Compiler compiler = createCompiler();
        List<Symbol> tokens = compiler.tokenize(compiler.parse(criteria.ccl()));
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNonNumericTag() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(Tag.create("bar")).build();
        Compiler compiler = createCompiler();
        List<Symbol> tokens = compiler.tokenize(compiler.parse(criteria.ccl()));
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testParseNumericNumber() {
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.EQUALS).value(17).build();
        Compiler compiler = createCompiler();
        List<Symbol> tokens = compiler.tokenize(compiler.parse(criteria.ccl()));
        for (Symbol token : tokens) {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Integer.class,
                        ((ValueSymbol) token).value().getClass());
            }
        }
    }

    @Test
    public void testCriteriaWithTimestampValueParse() {
        Timestamp start = Timestamp.now();
        Timestamp end = Timestamp.now();
        Criteria criteria = Criteria.where().key("foo")
                .operator(Operator.BETWEEN).value(start).value(end).build();
        Compiler compiler = createCompiler();
        int count = 0;
        for (Symbol symbol : compiler
                .tokenize(compiler.parse(criteria.ccl()))) {
            if(symbol instanceof ValueSymbol) {
                ValueSymbol $symbol = (ValueSymbol) symbol;
                Assert.assertEquals(Timestamp.class,
                        $symbol.value().getClass());
                Assert.assertTrue($symbol.value().equals(start)
                        || $symbol.value().equals(end));
                ++count;
            }
        }
        Assert.assertEquals(2, count);
    }

    @Test
    public void testParseOrderMultipleKeysWithIndependentDirection() {
        String ccl = "ORDER BY name ASC, age, email desc";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(3, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("email"),
                        TimestampSymbol.PRESENT, DirectionSymbol.DESCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithSingleKey() {
        String ccl = "ORDER BY name";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(1, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList
                .of(new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithSingleKeyDirection() {
        String ccl = "ORDER BY name DESC";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(1, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList
                .of(new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT, DirectionSymbol.DESCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithSingleKeyTimestamp() {
        String ccl = "ORDER BY name at last week";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(1, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList
                .of(new OrderComponentSymbol(new KeySymbol("name"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("last week"),
                                TimeUnit.DAYS),
                        DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithSingleKeyDirectionTimestamp() {
        String ccl = "ORDER BY name DESC at last week";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(1, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList
                .of(new OrderComponentSymbol(new KeySymbol("name"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("last week"),
                                TimeUnit.DAYS),
                        DirectionSymbol.DESCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithMultipleKeys() {
        String ccl = "ORDER BY name, age";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(2, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithMultipleKeysBothDirection() {
        String ccl = "ORDER BY name ASC, age desc";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(2, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        TimestampSymbol.PRESENT, DirectionSymbol.DESCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithMultipleKeysBothTimestamp() {
        String ccl = "ORDER BY name at last week, age at a month ago";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(2, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("last week"),
                                TimeUnit.DAYS),
                        DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("a month ago"),
                                TimeUnit.DAYS),
                        DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithMultipleKeysBothDirectionTimestamp() {
        String ccl = "ORDER BY name desc at last week, age ASC at a month ago";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(2, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("last week"),
                                TimeUnit.DAYS),
                        DirectionSymbol.DESCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("a month ago"),
                                TimeUnit.DAYS),
                        DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }

    @Test
    public void testParseOrderWithMultipleKeysSomeDirectionTimestamp() {
        String ccl = "ORDER BY name desc, email, age at a month ago";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        Assert.assertTrue(ast instanceof OrderTree);
        OrderTree tree = (OrderTree) ast;
        OrderSymbol symbol = (OrderSymbol) tree.root();
        Assert.assertEquals(3, symbol.components().size());
        List<OrderComponentSymbol> expectedComponents = ImmutableList.of(
                new OrderComponentSymbol(new KeySymbol("name"),
                        TimestampSymbol.PRESENT,
                        DirectionSymbol.DESCENDING),
                new OrderComponentSymbol(new KeySymbol("email"),
                        TimestampSymbol.PRESENT, DirectionSymbol.ASCENDING),
                new OrderComponentSymbol(new KeySymbol("age"),
                        new TimestampSymbol(
                                NaturalLanguage.parseMicros("a month ago"),
                                TimeUnit.DAYS),
                        DirectionSymbol.ASCENDING));
        for (int i = 0; i < expectedComponents.size(); ++i) {
            OrderComponentSymbol expected = expectedComponents.get(i);
            OrderComponentSymbol actual = symbol.components().get(i);
            Assert.assertEquals(expected, actual);
        }
    }
    
    @Test
    public void testParseLikeValueWithWhitespace() {
        String ccl = "school like %North Carolina%";
        Compiler compiler = createCompiler();
        AbstractSyntaxTree ast = compiler.parse(ccl);
        ExpressionTree expression = (ExpressionTree) ast;
        ExpressionSymbol symbol = (ExpressionSymbol) expression.root();
        Assert.assertEquals(new ValueSymbol("%North Carolina%"), symbol.values().iterator().next());
    }

    protected abstract Compiler createCompiler();

    private void doTestAbstractSyntaxTreeGeneration(String ccl) {
        Compiler compiler = createCompiler();
        Visitor<Queue<Symbol>> visitor = new Visitor<Queue<Symbol>>() {

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(CommandTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                if(tree.children().size() == 2) {
                    tree.conditionTree().accept(this, data);
                    tree.pageTree().accept(this, data);
                    return queue;
                }
                else {
                    tree.conditionTree().accept(this, data);
                    return queue;
                }
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(ConjunctionTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                tree.left().accept(this, data);
                tree.right().accept(this, data);
                queue.add(tree.root());
                return queue;
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(ExpressionTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                queue.add(tree.root());
                return queue;
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(OrderTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                queue.add(tree.root());
                return queue;
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(PageTree tree, Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                queue.add(tree.root());
                return queue;
            }

            @SuppressWarnings("unchecked")
            @Override
            public Queue<Symbol> visit(FunctionTree tree,
                    Object... data) {
                Queue<Symbol> queue = (Queue<Symbol>) data[0];
                queue.add(tree.root());
                return queue;
            }
        };
        Queue<Symbol> queue = compiler.parse(ccl).accept(visitor,
                new LinkedList<Symbol>());
        Assert.assertEquals(queue,
                compiler.arrange((ConditionTree) compiler.parse(ccl)));
    }

}
/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.function.Function;

import com.cinchapi.ccl.type.Operator;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.Multimap;

/**
 * Abstract implementation of {@link ParserTest}.
 * 
 * @author Jeff Nelson
 * 
 * @deprecated Replaced by {@link AbstractCompilerTest}
 */
@Deprecated
public abstract class AbstractParserTest extends ParserTest {

    @Override
    protected final Parser createParser(String ccl) {
        return createParser(ccl, (value) -> Convert.stringToJava(value),
                (operator) -> Convert.stringToOperator(operator));
    }

    @Override
    protected final Parser createParser(String ccl,
            Multimap<String, Object> data) {
        return createParser(ccl, data, (value) -> Convert.stringToJava(value),
                (operator) -> Convert.stringToOperator(operator));
    }

    protected abstract Parser createParser(String ccl,
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction);

    protected abstract Parser createParser(String ccl,
            Multimap<String, Object> data,
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction);

}/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.function.Function;
import java.util.stream.Collectors;

import org.junit.Assert;
import org.junit.Test;

import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.common.base.Array;
import com.cinchapi.concourse.thrift.TObject;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

/**
 * {@link ParserTest} that uses the {@link JavaCCParser}
 * 
 * @author Jeff Nelson
 * @deprecated Replaced by {@link CompilerJavaCCTest}
 */
@Deprecated
public class JavaCCParserTest extends AbstractParserTest {

    @Override
    protected Parser createParser(String ccl,
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction) {
        return Parser.create(ccl, valueTransformFunction,
                operatorTransformFunction);
    }

    @Override
    protected Parser createParser(String ccl, Multimap<String, Object> data,
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction) {
        return Parser.create(ccl, data, valueTransformFunction,
                operatorTransformFunction);
    }

    @Test
    public void testParseCclNoSpaces() {
        String ccl = "name=jeff";
        Parser parser = createParser(ccl);
        parser.order();

        Assert.assertEquals(ExpressionSymbol.create(new KeySymbol("name"),
                new OperatorSymbol(
                        com.cinchapi.concourse.thrift.Operator.EQUALS),
                new ValueSymbol("jeff")), parser.order().peek());
    }

    @Test
    public void testLocalEvaluationAnd() {
        String ccl = "a > 1 AND b bw 10 15";
        Parser parser = Parser.create(ccl, Convert::stringToJava,
                Convert::stringToOperator, (value, operator, values) -> {
                    TObject tvalue = Convert.javaToThrift(value);
                    TObject[] tvalues = values.stream()
                            .map(Convert::javaToThrift)
                            .collect(Collectors.toList())
                            .toArray(Array.containing());
                    com.cinchapi.concourse.thrift.Operator toperator = Convert
                            .stringToOperator(operator.symbol());
                    return tvalue.is(toperator, tvalues);
                });
        Multimap<String, Object> passes = ImmutableMultimap.of("a", 5, "b", 12,
                "c", 4, "a", -1);
        Assert.assertTrue(parser.evaluate(passes));
        Multimap<String, Object> fails = ImmutableMultimap.of("a", 1, "b", 12,
                "c", 4, "a", -1);
        Assert.assertFalse(parser.evaluate(fails));
        Multimap<String, Object> missing = ImmutableMultimap.of("a", 1, "c", 4,
                "a", -1);
        Assert.assertFalse(parser.evaluate(missing));
    }

    @Test
    public void testLocalEvaluationOr() {
        String ccl = "a > 1 OR b bw 10 15";
        Parser parser = Parser.create(ccl, Convert::stringToJava,
                Convert::stringToOperator, (value, operator, values) -> {
                    TObject tvalue = Convert.javaToThrift(value);
                    TObject[] tvalues = values.stream()
                            .map(Convert::javaToThrift)
                            .collect(Collectors.toList())
                            .toArray(Array.containing());
                    com.cinchapi.concourse.thrift.Operator toperator = Convert
                            .stringToOperator(operator.symbol());
                    return tvalue.is(toperator, tvalues);
                });
        Multimap<String, Object> a = ImmutableMultimap.of("a", 5, "b", 12, "c",
                4, "a", -1);
        Assert.assertTrue(parser.evaluate(a));
        Multimap<String, Object> b = ImmutableMultimap.of("a", 1, "b", 12, "c",
                4, "a", -1);
        Assert.assertTrue(parser.evaluate(b));
        Multimap<String, Object> c = ImmutableMultimap.of("a", 2, "c", 4, "a",
                -1);
        Assert.assertTrue(parser.evaluate(c));
        Multimap<String, Object> d = ImmutableMultimap.of("a", 1, "c", 4, "a",
                -1);
        Assert.assertFalse(parser.evaluate(d));
    }

}/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import com.cinchapi.ccl.grammar.ConjunctionSymbol;
import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.FunctionKeySymbol;
import com.cinchapi.ccl.grammar.FunctionValueSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ParenthesisSymbol;
import com.cinchapi.ccl.grammar.PostfixNotationSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.Symbol;
import com.cinchapi.ccl.syntax.AbstractSyntaxTree;
import com.cinchapi.ccl.syntax.AndTree;
import com.cinchapi.ccl.syntax.ConjunctionTree;
import com.cinchapi.ccl.syntax.ExpressionTree;
import com.cinchapi.ccl.syntax.OrTree;
import com.cinchapi.ccl.type.Operator;
import com.cinchapi.ccl.type.function.IndexFunction;
import com.cinchapi.ccl.type.function.KeyConditionFunction;
import com.cinchapi.ccl.type.function.KeyRecordsFunction;
import com.cinchapi.ccl.type.function.ImplicitKeyRecordFunction;
import com.cinchapi.concourse.Tag;
import com.cinchapi.concourse.lang.Criteria;
import com.cinchapi.concourse.util.Convert;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import org.junit.Assert;
import org.junit.Test;

import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.function.Function;

/**
 * Tests for {@link JavaCCParser}.
 *
 * These tests include utput tests (postfix, abstract
 * syntax tree, tokens)
 * 
 * @deprecated Replaced by {@link CompilerJavaCCLogicTest}
 */
@Deprecated
public class JavaCCParserLogicTest {

    @Test
    public void testSingleExpressionTokenize() {
        String ccl = "a = 1";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleBinaryExpressionTokenize() {
        String ccl = "a >< 1 3";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("><")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleNRegexExpressionTokenize() {
        String ccl = "name nregex (?i:%jeff%)";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("name"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("nregex")));
        expectedTokens.add(new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("(?i:%jeff%)")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleLikeExpressionTokenize() {
        String ccl = "name like (?i:%jeff%)";

        // Build expected queue
        List<Object> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("name"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("like")));
        expectedTokens.add(new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("(?i:%jeff%)")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        List<Symbol> tokens = parser.tokenize();
        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleConjunctionTokenize() {
        String ccl = "a = 1 and b = 2";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleDisjunctionTokenize() {
        String ccl = "a = 1 or b = 2";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDoubleConjunctionTokenize() {
        String ccl = "a = 1 and b = 2 and c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDoubleDisjunctionTokenize() {
        String ccl = "a = 1 or b = 2 or c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testConjunctionDisjunctionTokenize() {
        String ccl = "a = 1 and b = 2 or c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDisjunctionConjunctionTokenize() {
        String ccl = "a = 1 or b = 2 and c = 3";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionTokenize() {
        String ccl = "a = 1 and (b = 2 or c = 3)";

        // Build expected queue
        List<Symbol> expectedTokens = Lists.newArrayList();

        expectedTokens.add(new KeySymbol("a"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("1")));
        expectedTokens.add(ConjunctionSymbol.AND);
        expectedTokens.add(ParenthesisSymbol.LEFT);
        expectedTokens.add(new KeySymbol("b"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2")));
        expectedTokens.add(ConjunctionSymbol.OR);
        expectedTokens.add(new KeySymbol("c"));
        expectedTokens.add(new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("=")));
        expectedTokens.add(
                new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3")));
        expectedTokens.add(ParenthesisSymbol.RIGHT);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        List<Symbol> tokens = parser.tokenize();

        Assert.assertEquals(expectedTokens, tokens);
    }

    @Test
    public void testSingleConjunctionPostFix() {
        String ccl = "a = 1 and b = 2";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testSingleDisjunctionPostFix() {
        String ccl = "a = 1 or b = 2";
        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDoubleConjunctionPostFix() {
        String ccl = "a = 1 and b = 2 and c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDoubleDisjunctionPostFix() {
        String ccl = "a = 1 or b = 2 or c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testConjunctionDisjunctionPostFix() {
        String ccl = "a = 1 and b = 2 or c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDisjunctionConjunctionPostFix() {
        String ccl = "a = 1 or b = 2 and c = 3";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);
        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionPostFix() {
        String ccl = "a = 1 or (b = 2 and c = 3)";

        // Build expected queue
        Queue<PostfixNotationSymbol> expectedOrder = new LinkedList<>();

        KeySymbol key = new KeySymbol("a");
        OperatorSymbol operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        ValueSymbol value = new ValueSymbol(
                PARSER_TRANSFORM_VALUE_FUNCTION.apply("1"));
        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        expectedOrder.add(expression);

        key = new KeySymbol("b");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("2"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        key = new KeySymbol("c");
        operator = new OperatorSymbol(
                PARSER_TRANSFORM_OPERATOR_FUNCTION.apply("="));
        value = new ValueSymbol(PARSER_TRANSFORM_VALUE_FUNCTION.apply("3"));
        expression = ExpressionSymbol.create(key, operator, value);
        expectedOrder.add(expression);

        expectedOrder.add(ConjunctionSymbol.AND);
        expectedOrder.add(ConjunctionSymbol.OR);

        // Generate queue
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        Queue<PostfixNotationSymbol> order = parser.order();

        Assert.assertEquals(expectedOrder, order);
    }

    @Test
    public void testSingleExpressionAbstractSyntaxTree() {
        String ccl = "a = 1";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());
    }

    @Test
    public void testSingleBinaryExpressionAbstractSyntaxTree() {
        String ccl = "a >< 1 2";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("a", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        Assert.assertEquals("1", expression.values().get(0).toString());
        Assert.assertEquals("2", expression.values().get(1).toString());
    }

    @Test
    public void testSingleConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof AndTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Left node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("b", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("2", rightExpression.values().get(0).toString());
    }

    @Test
    public void testSingleDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Left node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("b", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("2", rightExpression.values().get(0).toString());
    }

    @Test
    public void testDoubleConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2 and c = 3";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof AndTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof AndTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", rightRightExpression.key().toString());
        Assert.assertEquals("=", rightRightExpression.operator().toString());
        Assert.assertEquals("2",
                rightRightExpression.values().get(0).toString());
    }

    @Test
    public void testDoubleDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2 or c = 3";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof OrTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("2",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testConjunctionDisjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and b = 2 or c = 3";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // left node
        Assert.assertTrue(rootNode.left() instanceof AndTree);
        ConjunctionTree leftNode = (ConjunctionTree) rootNode.left();

        // right node
        Assert.assertTrue(rootNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightExpression = (ExpressionSymbol) (rootNode.right())
                .root();
        Assert.assertEquals("c", rightExpression.key().toString());
        Assert.assertEquals("=", rightExpression.operator().toString());
        Assert.assertEquals("3", rightExpression.values().get(0).toString());

        // Left left node
        Assert.assertTrue(leftNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftLeftExpression = (ExpressionSymbol) (leftNode
                .left()).root();
        Assert.assertEquals("a", leftLeftExpression.key().toString());
        Assert.assertEquals("=", leftLeftExpression.operator().toString());
        Assert.assertEquals("1", leftLeftExpression.values().get(0).toString());

        // Left right node
        Assert.assertTrue(leftNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (leftNode
                .right()).root();
        Assert.assertEquals("b", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("2",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testDisjunctionConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 or b = 2 and c = 3";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof OrTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Right node
        Assert.assertTrue(rootNode.right() instanceof AndTree);
        ConjunctionTree rightNode = (ConjunctionTree) rootNode.right();

        // right node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right left node
        Assert.assertTrue(rightNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightLeftExpression = (ExpressionSymbol) (rightNode
                .left()).root();
        Assert.assertEquals("b", rightLeftExpression.key().toString());
        Assert.assertEquals("=", rightLeftExpression.operator().toString());
        Assert.assertEquals("2",
                rightLeftExpression.values().get(0).toString());

        // Right right node
        Assert.assertTrue(rightNode.right() instanceof ExpressionTree);
        ExpressionSymbol rightRightExpression = (ExpressionSymbol) (rightNode
                .right()).root();
        Assert.assertEquals("c", rightRightExpression.key().toString());
        Assert.assertEquals("=", rightRightExpression.operator().toString());
        Assert.assertEquals("3",
                rightRightExpression.values().get(0).toString());
    }

    @Test
    public void testDisjunctionParenthesizedConjunctionAbstractSyntaxTree() {
        String ccl = "a = 1 and (b = 2 or c = 3)";

        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);

        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof AndTree);
        ConjunctionTree rootNode = (ConjunctionTree) tree;

        // Left node
        Assert.assertTrue(rootNode.left() instanceof ExpressionTree);
        ExpressionSymbol leftExpression = (ExpressionSymbol) (rootNode.left())
                .root();
        Assert.assertEquals("a", leftExpression.key().toString());
        Assert.assertEquals("=", leftExpression.operator().toString());
        Assert.assertEquals("1", leftExpression.values().get(0).toString());

        // Right node
        Assert.assertTrue(rootNode.right() instanceof OrTree);
        ConjunctionTree rightNode = (ConjunctionTree) rootNode.right();

        // Right left node
        Assert.assertTrue(rightNode.left() instanceof ExpressionTree);
        ExpressionSymbol rightLeftExpression = (ExpressionSymbol) (rightNode
                .left()).root();
        Assert.assertEquals("b", rightLeftExpression.key().toString());
        Assert.assertEquals("=", rightLeftExpression.operator().toString());
        Assert.assertEquals("2",
                rightLeftExpression.values().get(0).toString());

        // Right right node
        Assert.assertTrue(rightNode.right() instanceof ExpressionTree);
        ExpressionSymbol leftRightExpression = (ExpressionSymbol) (rightNode
                .right()).root();
        Assert.assertEquals("c", leftRightExpression.key().toString());
        Assert.assertEquals("=", leftRightExpression.operator().toString());
        Assert.assertEquals("3",
                leftRightExpression.values().get(0).toString());
    }

    @Test
    public void testParseCclLocalReferences() {
        String ccl = "name = $name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");

        // Generate tree
        Parser parser = Parser.create(ccl, data,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Lebron James\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testEscapedCclLocalReferences() {
        String ccl = "name = \\$name";
        Multimap<String, Object> data = LinkedHashMultimap.create();
        data.put("name", "Lebron James");
        data.put("age", 30);
        data.put("team", "Cleveland Cavaliers");

        // Generate tree
        Parser parser = Parser.create(ccl, data,
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("$name", expression.values().get(0).toString());
    }

    @Test
    public void testDoubleQuotedValue() {
        String ccl = "name = \"Javier Lores\"";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Javier Lores\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testDoubleRightAndLeftQuotedValue() {
        String ccl = "name = “Javier Lores”";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("\"Javier Lores\"",
                expression.values().get(0).toString());
    }

    @Test
    public void testQuotedValueWithinQuotedString() {
        String ccl = "name = \"Javier \\\"Lores\"";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("'Javier \"Lores'",
                expression.values().get(0).toString());
    }

    @Test
    public void testNonQuoteEscapedValueWithinQuoteString() {
        String ccl = "name = \"Javier \\\"\\@Lores\"";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("'Javier \"\\@Lores'",
                expression.values().get(0).toString());
    }

    @Test
    public void validEscapedLocalResolution() {
        String ccl = "name = \\$name";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("$name", expression.values().get(0).toString());
    }

    @Test
    public void validEscapedImplicitLink() {
        String ccl = "name = \\@name";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("@name", expression.values().get(0).toString());
    }

    @Test
    public void validLink() {
        String ccl = "name -> 30";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("LINKS_TO", expression.operator().toString());
        Assert.assertEquals("30", expression.values().get(0).toString());
    }

    @Test
    public void validOperatorEnum() {
        String ccl = "name LINKS_TO 30";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("name", expression.key().toString());
        Assert.assertEquals("LINKS_TO", expression.operator().toString());
        Assert.assertEquals("30", expression.values().get(0).toString());
    }

    @Test
    public void testNavigationKey() {
        String ccl = "mother.children = 3";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother.children", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testLongNavigationKey() {
        String ccl = "mother.mother.siblings = 3";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother.mother.siblings",
                expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testPeriodSeparatedValue() {
        String ccl = "mother = a.b.c";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("mother", expression.key().toString());
        Assert.assertEquals("=", expression.operator().toString());
        Assert.assertEquals("a.b.c", expression.values().get(0).toString());
    }

    @Test
    public void testImplicitRecordFunctionAsEvaluationKey() {
        String ccl = "friends | avg > 3";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertTrue(expression.key() instanceof FunctionKeySymbol);
        FunctionKeySymbol symbol = expression.key();
        Assert.assertEquals("avg", symbol.key().operation());
        Assert.assertEquals("friends", symbol.key().key());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertEquals("3", expression.values().get(0).toString());
    }

    @Test
    public void testImplicitIndexFunctionAsEvaluationValue() {
        String ccl = "age > avg(age)";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((IndexFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((IndexFunction) expression.values().get(0).value()).key());
    }

    @Test
    public void testExplicitFunctionWithSingleRecordAsEvaluationValue() {
        String ccl = "age > avg(age, 1)";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .key());
        Assert.assertEquals(1, ((List<Long>) ((KeyRecordsFunction) expression
                .values().get(0).value()).source()).size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(0));
    }

    @Test
    public void testExplicitFunctionWithBetween() {
        String ccl = "age bw avg(age) 1000";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((IndexFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((IndexFunction) expression.values().get(0).value()).key());

        Assert.assertEquals("1000", expression.values().get(1).toString());
    }

    @Test
    public void testExplicitFunctionWithBetweenCCL() {
        String ccl = "age bw avg(age, age > 10) 1000";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals("><", expression.operator().toString());
        KeyConditionFunction function = (KeyConditionFunction) expression
                .values().get(0).value();
        Assert.assertTrue(function.source() instanceof ExpressionTree);
        ExpressionTree t = (ExpressionTree) function.source();
        ExpressionSymbol root = (ExpressionSymbol) t.root();
        Assert.assertEquals("age", root.key().key());
        Assert.assertEquals(">", root.operator().operator().symbol());
        Assert.assertEquals(10, root.values().get(0).value());

        Assert.assertEquals("1000", expression.values().get(1).toString());
    }

    @Test
    public void testExplicitFunctionWithMultipleRecordsAsEvaluationValue() {
        String ccl = "age > avg(age, 1, 2)";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyRecordsFunction) expression.values().get(0).value())
                        .key());
        Assert.assertEquals(2, ((List<Long>) ((KeyRecordsFunction) expression
                .values().get(0).value()).source()).size());
        Assert.assertEquals((long) 1,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(0));
        Assert.assertEquals((long) 2,
                (long) ((List<Long>) ((KeyRecordsFunction) expression.values()
                        .get(0).value()).source()).get(1));
    }

    @Test
    public void testExplicitFunctionWithCCLAsEvaluationValue() {
        String ccl = "age > avg(age, age < 30)";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("age", expression.key().toString());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .key());

        Assert.assertTrue(
                (((KeyConditionFunction) expression.values().get(0).value())
                        .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).key()
                                .toString());
        Assert.assertEquals("<",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).operator()
                                .toString());
        Assert.assertEquals("30",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).values()
                                .get(0).toString());
    }

    @Test
    public void validImplicitRecordFunctionAsEvaluationKeyAndExplicitFunctionWithCCLAsEvaluationValue() {
        String ccl = "age | avg > avg(age, age < 30)";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertTrue(expression.key() instanceof FunctionKeySymbol);
        Assert.assertEquals("avg",
                ((ImplicitKeyRecordFunction) expression.key().key())
                        .operation());
        Assert.assertEquals(">", expression.operator().toString());
        Assert.assertTrue(
                expression.values().get(0) instanceof FunctionValueSymbol);
        Assert.assertEquals("avg",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .operation());
        Assert.assertEquals("age",
                ((KeyConditionFunction) expression.values().get(0).value())
                        .key());

        Assert.assertTrue(
                (((KeyConditionFunction) expression.values().get(0).value())
                        .source()) instanceof ExpressionTree);
        Assert.assertEquals("age",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).key()
                                .toString());
        Assert.assertEquals("<",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).operator()
                                .toString());
        Assert.assertEquals("30",
                ((ExpressionSymbol) ((AbstractSyntaxTree) ((KeyConditionFunction) expression
                        .values().get(0).value()).source()).root()).values()
                                .get(0).toString());
    }

    @Test
    public void testJsonReservedIdentifier() {
        String ccl = "$id$ != 40";

        // Generate tree
        Parser parser = Parser.create(ccl, PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        AbstractSyntaxTree tree = parser.parse();

        // Root node
        Assert.assertTrue(tree instanceof ExpressionTree);
        ExpressionSymbol expression = (ExpressionSymbol) tree.root();
        Assert.assertEquals("$id$", expression.key().toString());
        Assert.assertEquals("!=", expression.operator().toString());
        Assert.assertEquals("40", expression.values().get(0).toString());
    }

    @Test
    public void testReproIX5A() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("_")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value("org.internx.model.data.user.Student"))
                .and()
                .group(Criteria.where()
                        .group(Criteria.where().key("group").operator(
                                com.cinchapi.concourse.thrift.Operator.LIKE)
                                .value("%Accounting And Business/management%"))
                        .or()
                        .group(Criteria.where().key("major").operator(
                                com.cinchapi.concourse.thrift.Operator.LIKE)
                                .value("%accounting and business/management%")));

        // Generate tree
        Parser parser = Parser.create(criteria.ccl(),
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        parser.tokenize().forEach(token -> {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(String.class,
                        ((ValueSymbol) token).value().getClass());
            }
        });
    }

    @Test
    public void testReproIX5B() {
        Criteria criteria = Criteria.where()
                .group(Criteria.where().key("_")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(Tag
                                .create("org.internx.model.data.user.Student")))
                .and()
                .group(Criteria.where().group(Criteria.where().key("group")
                        .operator(com.cinchapi.concourse.thrift.Operator.EQUALS)
                        .value(Tag
                                .create("Accounting And Business/management")))
                        .or()
                        .group(Criteria.where().key("major").operator(
                                com.cinchapi.concourse.thrift.Operator.EQUALS)
                                .value(Tag.create(
                                        "accounting and business/management"))));

        // Generate tree
        Parser parser = Parser.create(criteria.ccl(),
                PARSER_TRANSFORM_VALUE_FUNCTION,
                PARSER_TRANSFORM_OPERATOR_FUNCTION);
        parser.tokenize().forEach(token -> {
            if(token instanceof ValueSymbol) {
                Assert.assertEquals(Tag.class,
                        ((ValueSymbol) token).value().getClass());
            }
        });
    }

    /**
     * The canonical function to transform strings to java values in a
     * {@link Parser}.
     */
    public final Function<String, Object> PARSER_TRANSFORM_VALUE_FUNCTION = value -> Convert
            .stringToJava(value);

    /**
     * The canonical function to transform strings to operators in a
     * {@link Parser}.
     */
    public final Function<String, Operator> PARSER_TRANSFORM_OPERATOR_FUNCTION = operator -> Convert
            .stringToOperator(operator);

    /**
     *
     */
    @SuppressWarnings("unused")
    private void printPreOrder(AbstractSyntaxTree tree) {
        System.out.println(tree.root());
        for (AbstractSyntaxTree child : tree.children()) {
            printPreOrder(child);
        }
    }
}/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl;

import java.util.function.Function;

import com.cinchapi.ccl.type.Operator;
import com.cinchapi.concourse.util.Convert;

/**
 * Abstract implementation of {@link CompilerTest}.
 * 
 * @author Jeff Nelson
 */
public abstract class AbstractCompilerTest extends CompilerTest {

    @Override
    protected final Compiler createCompiler() {
        return createCompiler((value) -> Convert.stringToJava(value),
                (operator) -> Convert.stringToOperator(operator));
    }
    
    protected abstract Compiler createCompiler(
            Function<String, Object> valueTransformFunction,
            Function<String, Operator> operatorTransformFunction);
}
/*
 * Copyright (c) 2013-2017 Cinchapi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.cinchapi.ccl.syntax;

import com.cinchapi.ccl.grammar.ExpressionSymbol;
import com.cinchapi.ccl.grammar.KeyTokenSymbol;
import com.cinchapi.ccl.grammar.OperatorSymbol;
import com.cinchapi.ccl.grammar.ValueSymbol;
import com.cinchapi.ccl.grammar.KeySymbol;
import com.cinchapi.ccl.grammar.ValueTokenSymbol;
import com.cinchapi.concourse.thrift.Operator;
import org.junit.Assert;
import org.junit.Test;

/**
 * Tests for the {@link Visitor} interface
 */
public class VisitorTest {

    @Test
    public void testVisitorPattern() {
        // Build tree
        KeyTokenSymbol<String> key = new KeySymbol("key");
        OperatorSymbol operator = new OperatorSymbol(Operator.EQUALS);
        ValueTokenSymbol<Object> value = new ValueSymbol("value");

        ExpressionSymbol expression = ExpressionSymbol.create(key, operator,
                value);
        ExpressionTree leftTree = new ExpressionTree(expression);

        key = new KeySymbol("key");
        operator = new OperatorSymbol(Operator.EQUALS);
        value = new ValueSymbol("value");

        expression = ExpressionSymbol.create(key, operator, value);
        ExpressionTree rightTree = new ExpressionTree(expression);

        AndTree tree = new AndTree(leftTree, rightTree);

        // Test visitor
        Visitor<Object> visitor = new Visitor<Object>() {
            @Override
            public Object visit(CommandTree tree, Object... data) {
                return data;
            }

            @Override
            public Object visit(ConjunctionTree tree, Object... data) {
                Assert.assertTrue(tree instanceof AndTree);
                return data;
            }

            @Override
            public Object visit(ExpressionTree tree, Object... data) {
                Assert.assertTrue(((ExpressionSymbol) tree.root()).key()
                        .toString().equals("key"));
                Assert.assertTrue(((ExpressionSymbol) tree.root()).operator()
                        .toString().equals("="));
                Assert.assertTrue(((ExpressionSymbol) tree.root()).values()
                        .get(0).toString().equals("value"));
                return data;
            }

            @Override
            public Object visit(PageTree tree, Object... data) {
                return data;
            }

            @Override
            public Object visit(OrderTree tree, Object... data) {
                return data;
            }

            @Override
            public Object visit(FunctionTree tree, Object... data) {
                return data;
            }

        };
        tree.accept(visitor);
    }

}
